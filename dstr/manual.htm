<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
   <TITLE> manual file </TITLE>

<STYLE>

li, div, td
   {mso-style-parent:"";
   margin:0cm;
   margin-bottom:.0001pt;
   mso-pagination:widow-orphan;
   font-size:10.0pt;
   font-family:"Times New Roman";
   mso-fareast-font-family:"Times New Roman";}

ul
   {margin-bottom:0cm;
   font-size:10.0pt;
   font-family:"Times New Roman";
   mso-fareast-font-family:"Times New Roman";}

h1
   {margin-right:0cm;
   mso-margin-top-alt:auto;
   mso-margin-bottom-alt:auto;
   margin-left:0cm;
   mso-pagination:widow-orphan;
   mso-outline-level:1;
   font-size:24.0pt;
   font-family:"Times Bold";
   mso-font-kerning:18.0pt;
   font-weight:bold;}
h2
   {margin-right:0cm;
   mso-margin-top-alt:auto;
   mso-margin-bottom-alt:auto;
   margin-left:0cm;
   mso-pagination:widow-orphan;
   mso-outline-level:2;
   font-size:18.0pt;
   font-family:"Times New Roman";
   font-weight:bold;}
h3
   {margin-right:0cm;
   mso-margin-top-alt:auto;
   mso-margin-bottom-alt:auto;
   margin-left:0cm;
   mso-pagination:widow-orphan;
   mso-outline-level:3;
   font-size:14.0pt;
   font-family:"Times New Roman";
   font-weight:bold;}
h4
   {margin-right:0cm;
   mso-margin-top-alt:auto;
   mso-margin-bottom-alt:auto;
   margin-left:0cm;
   mso-pagination:widow-orphan;
   mso-outline-level:4;
   font-size:12.0pt;
   font-family:"Times New Roman";
   font-weight:bold;}
p
   {margin-right:0cm;
   mso-margin-top-alt:auto;
   mso-margin-bottom-alt:auto;
   margin-left:0cm;
   mso-pagination:widow-orphan;
   font-size:10.0pt;
   font-family:"Times New Roman";
   mso-fareast-font-family:"Times New Roman";}
pre
   {margin:0cm;
   margin-bottom:.0001pt;
   font-size:10.0pt;
   font-family:"Courier New";
   mso-fareast-font-family:"Courier New";}

</STYLE>

</HEAD>

<BODY>

<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>

<P ALIGN=RIGHT>
<FONT SIZE=5>
<B>Программное обеспечение</B>
</FONT>
</P>
<HR COLOR=BLACK SIZE=4>

<P ALIGN=RIGHT>
<FONT SIZE=6>
<B>LComp</B>
</FONT>
</P>
<P ALIGN=RIGHT>
<FONT SIZE=4>
<B>Руководство программиста</B>
</FONT>
</P>
<P ALIGN=RIGHT>
<FONT SIZE=3>
<I>
Комплект ПО для разработки приложений (SDK)<BR>
Windows 98/Me/2000/XP<BR> 
L-264/L-305/L-1221/L-1250/L-1450/L-761/L-780/L-783/L-791/E14-440/E14-140/E20-10/E154
</I>
</FONT>
</P>

<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>

<TABLE BORDER=0
WIDTH=100% style='border:solid white'>
<TBODY>
<TR>
<TD ALIGN=LEFT style='border:solid white'>
<IMG WIDTH=120 SRC='x.gif'>
</TD>
<TD ALIGN=RIGHT style='border:solid white'>
<FONT SIZE=1>
<I>
Москва. Февраль. 2003<BR>
Ревизия 1.0
</I>
</FONT>
</TD>
</TR>
</TABLE>

<br clear=all style='page-break-before:always'>

<!--  вторая страница с телефонами!-->
<BR>
<BR>
<BR>
<BR>
<BR>
<P><FONT SIZE=4><B>ЗАО "Л-КАРД"</B></FONT></P>
<UL>
117105, г. Москва, Варшавское ш., д. 5, корп. 4, стр. 2<BR>
тел.: (095) 785-95-25<BR>
факс: (095) 785-95-14<BR>
</UL>

<P><FONT SIZE=4><B>Адреса в Интернет:</B></FONT></P>
<UL>
www.lcard.ru<BR>
ftp.lcard.ru<BR>
</UL>

<P><FONT SIZE=4><B>E-Mail:</B></FONT></P>
<UL>
Отдел продаж: sale@lcard.ru<BR>
Техническая поддержка: support@lcard.ru<BR>
Отдел кадров: job@lcard.ru<BR>
Общие вопросы: lcard@lcard.ru<BR>
</UL>

<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>

<P><FONT SIZE=4><B>Представители в регионах:</B></FONT></P>
<UL>
Украина: HOLIT Data Sistems, www.holit.com.ua, (044) 241-6754<BR>
Санкт-Петербург: Autex Spb Ltd., www.autex.spb.ru, (812) 567-7202<BR>
Новосибирск: Сектор-Т, www.sector-t.ru, (383-2) 396-592<BR>
Екатеринбург: Аск, www.ask.ru, 71-4444<BR>
Казань: ООО ’Шатл’, shuttle@kai.ru, (8432) 38-1600<BR>
</UL>

<br clear=all style='page-break-before:always'>
<H2>Предупреждение</H2>

<P>Version 6.0r0</P>
<P>Copyright (c) 1998-2008 L-Card Ltd.</P>
<P>Интерфейс и функциональные возможности драйвера и библиотеки могут
измениться в последующих версиях. 
</P>
<P>Учтите это при проектировании своих приложений. 
</P>
<P>Корректная поддержка плат с помощью это драйвера возможна только
при соответствующих прошивках BIOS ADSP. Пока это выполняется для
L-305 L-264 L-1250 L-1251 L-1221 L-761 L-780 L-783 L-1450 L-791 E14-440 E14-140 E20-10 E154. 
</P>

<br clear=all style='page-break-before:always'>
<H2>Описание технологии</H2>

<P>Данный релиз драйвера и библиотеки поддерживает следующие платы: 
</P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=3>
   <COL WIDTH=13*>
   <COL WIDTH=24*>
   <COL WIDTH=24*>
   <COL WIDTH=195*>
   <TR>
      <TD WIDTH=5%>
         <P>L032</P>
      </TD>
      <TD WIDTH=9%>
         <P>ISA</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76%>
         <P>Установите плату как L-1250 и используйте функции ввода/вывода
         в порты.</P>
      </TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>L305</P>
      </TD>
      <TD WIDTH=9%>
         <P>ISA</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>L264</P>
      </TD>
      <TD WIDTH=9%>
         <P>ISA</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>L1250</P>
      </TD>
      <TD WIDTH=9%>
         <P>ISA</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>L1450</P>
      </TD>
      <TD WIDTH=9%>
         <P>ISA</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>L1620</P>
      </TD>
      <TD WIDTH=9%>
         <P>ISA</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76%>
         <P>Установите плату как L-1250, при загрузке используйте БИОС от
         платы L-1620. Далее вызывайте функции L-1250. Разница только в
         формате данных.</P>
      </TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>L1251</P>
      </TD>
      <TD WIDTH=9%>
         <P>ISA with fast read</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>L1221</P>
      </TD>
      <TD WIDTH=9%>
         <P>ISA with fast read</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>L761</P>
      </TD>
      <TD WIDTH=9%>
         <P>PCI</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>L780</P>
      </TD>
      <TD WIDTH=9%>
         <P>PCI</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>L783</P>
      </TD>
      <TD WIDTH=9%>
         <P>PCI</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>L791</P>
      </TD>
      <TD WIDTH=9%>
         <P>PCI</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>E14-440</P>
      </TD>
      <TD WIDTH=9%>
         <P>USB</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>E14-140</P>
      </TD>
      <TD WIDTH=9%>
         <P>USB</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>E20-10</P>
      </TD>
      <TD WIDTH=9%>
         <P>USB</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>
   <TR>
      <TD WIDTH=5%>
         <P>E154</P>
      </TD>
      <TD WIDTH=9%>
         <P>USB</P>
      </TD>
      <TD WIDTH=9%>
         <P>2000/XP</P>
      </TD>
      <TD WIDTH=76% VALIGN=TOP></TD>
   </TR>

</TABLE>
<P>Принцип действия: 
</P>
<P>Устройство АЦП собирает данные в кольцевой буфер или FIFO,
реализованный в ОЗУ сигнального процессора или микросхемы ПЛИС. При
заполнении части буфера генерируется прерывание. Драйвер устройства
по этим прерываниям вычитывает данные и помещает их в большой
кольцевой буфер, реализованный в ОЗУ компьютера. Большой кольцевой
буфер драйвера доступен пользовательскому приложению - имеется
указатель на начало этого буфера. Кроме этого пользователю доступен
счетчик заполнения буфера (тоже посредством указателя). Используя
этот счетчик, пользователь может забирать данные из правильной части
кольцевого буфера (т.е. из той, в которую драйвер уже записал
данные). 
</P>
<P>Приложение может: 
</P>
<UL>
   <P>- забирать данные из буфера для сохранения непрерывного потока
   данных;<BR>- обрабатывать данные на месте - тогда старые данные
   будут замещаться новыми;</P>
</UL>
<P>Связь драйвера с приложением возможна двумя способами: 
</P>
<UL>
   <P>- чтение счетчика заполнения буфера (циклическое заполнение
   буфера);<BR>- ожидание сообщения о готовности буфера (однократное
   заполнение буфера);</P>
</UL>
<P>Первый способ работает всегда, но требует ресурсов от компьютера
при ожидании в цикле. Второй способ удобно использовать при
осциллографическом режиме работы. 
</P>
<P>Использование такого режима работы - по прерываниям - обусловлено
тем, что платы PCI L-761/780/L783 построены на микросхеме без
поддержки BusMastering и для них такой способ ввода непрерывного
потока данных является единственно возможным. При этом загрузка ЦПУ
минимальна благодаря высокой скорости чтения на шине PCI. Для ISA
плат при таком режиме работы удается достичь наивысшей скорости
передачи данных, однако для них загрузка процессора может достигать
50-90% на предельных скоростях, что не очень хорошо, но все же
позволяет осуществлять непрерывный сбор данных на диск.</P>
<P>Для ISA плат поддерживающих ввод/вывод данных по DMA введен еще
один режим. В этом режиме плата передает данные в компьютер по DMA в
режиме автоинициализации. Буфер DMA маленький - до 2048 слов. При
заполнении половины этого буфера плата генерирует прерывание, по
которому драйвер копирует данные из буфера DMA в большой кольцевой
буфер. Кроме этого возможен одновременный вывод на ЦАП платы данных
из такого же маленького буфера - по DMA с автоинициализацией. В таком
режиме работы скорость ввода данных не превышает 200 кГц, но при этом
загрузка машины существенно ниже. Возможна работа двух плат на ввод
по DMA. 
</P>
<P>Для платы L791 режим ввода и принцип сбора немного другие. Эта
плата поддерживает режим ввода/вывода BusMaster. При этом основной
принцип работы с библиотекой остается прежний &ndash; приложение
забирает данные из кольцевого буфера в памяти компьютера. Только
поступают они туда не по прерывания от платы, а по BusMaster-каналу.
Заполнение буфера контролируется также по чтению счетчика, только
этот счетчик находится непосредственно в плате. Прерывания от платы
тоже могут выступать сигналами готовности данных &ndash; пользователь
может установить события на них и потом обрабатывать.</P>
<P>Для USB модулей реализован также принцип кольцевого буфера путем
циклической перепосылки запросов на ввод данных. Работа с ЦАП  в
потоковом режиме для этих модулей не поддерживается. Она возможна при
использовании библиотек не совместимых с LComp &ndash; LUsbApi. При
этом используется другой интерфейс драйвера ldevusbu.sys.</P>
<P><BR><BR>
</P>

<br clear=all style='page-break-before:always'>
<H2>Установка и настройка PCI плат</H2>

<P>Первое правило при установке плат - необходимо убедиться, что
компьютер настроен и все драйвера для него установлены. Особенно
драйвера для чипсета. Также надо проверить, что в плате L-Card
прошита самая свежая конфигурационная ПЗУ (см. каталог UTILS после
установки драйверов). Как правило, для установки PCI платы необходимо
просто вставить ее в компьютер и установить драйвера. После этого
плата готова к использованию. Но возможны ситуации, когда это не так.
Новые драйвера - это полноценные WDM драйвера способные работать в
Windows c поддержкой ACPI и соответственно shared IRQ. Но возможны
ситуации, когда другие устройства некорректно работают с ACPI и при
этом разделяют ресурсы с платой L-Card. Тогда возможны зависания
системы и частичная или полная неработоспособность платы L-Card или
какой-то другой. Для решения этой проблемы, необходимо какими либо
средствами исключить разделение ресурсов платой L-Card c другими
устройствами компьютера. Разделение ресурсов также может понизить
производительность системы и/или платы L-Card и тогда тоже желательно
его ликвидировать. Ниже приведены пути отключения ACPI и исключения
ситуации Shared IRQ для Windows 98 и 2000 (под Me и XP аналогично). 
</P>
<P>Общая часть: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">В БИОСЕе компьютера надо поискать
	ключ вида <B>Plug &amp; Play OS Installed</B> и установить его в <B>No</B>.
	Это заставит именно БИОС производить первоначальную настройку PCI
	плат и Windows, потом будет использовать именное ее. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">В БИОСе компьютера найти, если
	есть ключ <B>ACPI function</B> и поставить его в <B>Disabled</B>. 
	</P>
	<LI><P>В БИОСе компьютера найти, если есть ключи вида <B>PCI
	Slot(0,1..) use IRQ</B> и поставить там фиксированное свободное
	прерывание вместо <B>Auto</B>. 
	</P>
</UL>
<P>Если это все проделать на компьютере до установки ОС, то при
установке ОС она установится в варианте без поддержки ACPI. Если ОС
уже стоит, то придется отключить ACPI в ОС. 
</P>
<P>Windows 98: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">Загрузиться в <B>Safe Mode</B>. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Зайти в <B>Панель Управления</B>. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Открыть иконку <B>Система</B>. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">В ней в <B>Диспетчере устройств</B>
	выбрать <B>Системные устройства</B>. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Если у Вас там значится <B>Plug &amp;
	play BIOS</B> и нет нигде слова ACPI, то и ACPI соответственно нет и
	ничего делать больше не надо. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Иначе надо удалить все системные
	устройства, а <B>Системная кнопка ACPI</B> заменить на <B>Plug &amp;
	play BIOS</B> с помощью обновления драйвера(выбрать все устройства).
		</P>
	<LI><P STYLE="margin-bottom: 0cm">Перезагрузиться. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Посмотреть в <B>Диспетчер
	устройств</B>. Там все должно быть в одном экземпляре и без
	восклицательных знаков. Если это не так, то надо удалять дублеров
	вместе с оригиналами и перезагружаться пока все не придет в норму. К
	сожалению, это процесс довольно трудно формализуется(PCI irq holder
	может быть много - это нормально). 
	</P>
	<LI><P>Как результат у Вас должна получиться нормальная система с
	<B>Plag &amp; play BIOS</B> в системных устройствах. 
	</P>
</UL>
<P>Windows 2000: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">Зайти в <B>Панель Управления</B>. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Открыть иконку <B>Система</B>. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Выбрать закладку <B>Оборудование</B>.
		</P>
	<LI><P STYLE="margin-bottom: 0cm">В ней в <B>Диспетчере устройств</B>
	выбрать <B>Компьютер</B>. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Если у Вас там значится <B>Standart
	PC</B>,то ACPI соответственно нет и ничего делать больше не надо. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Иначе надо сменить тип компьютера
	на <B>Standart PC</B> с помощью кнопки обновления драйвера (выбрать
	все устройства). 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Перезагрузиться. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Посмотреть в <B>Диспетчер
	устройств</B>. Там все должно быть в одном экземпляре и без
	восклицательных знаков. Если это не так то надо удалять дублеров
	вместе с оригиналами и перезагружаться пока все не придет в норму. К
	сожалению, это процесс довольно трудно формализуется. 
	</P>
	<LI><P>Как результат у Вас должна получиться нормальная система с
	типом компьютера <B>Standart PC</B>. 
	</P>
</UL>
<P>Если ресурсы по прежнему разделяются, то можно попробовать
переставить плату L-Card в другой слот PCI т.к. некоторые слоты PCI
всегда разделяют прерывания с AGP слотом или дополнительными PCI
слотами (если слотов &gt;4). 
</P>

<br clear=all style='page-break-before:always'>
<H2>Установка и настройка ISA плат</H2>

<P>Первое правило при установке плат - необходимо убедиться, что
компьютер настроен и все драйвера для него установлены. Особенно
драйвера для чипсета. После установки платы в компьютер и инсталляции
драйверов надо вызвать мастер установки новых устройств Windows: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">Далее выбрать <B>Добавить
	устройство</B>. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Подождать пока система поищет в
	своей базе, и выбрать <B>Добавить новое устройство</B>. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Выбрать <B>Выбор из списка</B>. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Выбрать <B>L-Card ADC/DAC ISA
	boards</B>. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Выбрать нужную плату - появится
	диалог настройки ресурсов. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">В диалоге выбрать нужную
	конфигурацию и настроить ресурсы в соответствии с установленными
	перемычками. Не обязательно выбирать самую сложную конфигурацию.
	Можно ограничиться просто адресом и прерыванием, если требуется
	только ввод с АЦП и наоборот вывод на ЦАП будет работать только при
	конфигурации с ПДП для ЦАП. Некоторые платы требуют для работы АЦП
	наличие ПДП. 
	</P>
	<LI><P>Завершить работу мастера и перезагрузить компьютер - в списке
	устройств должна появиться установленная плата с выбранными
	ресурсами. 
	</P>
</UL>

<br clear=all style='page-break-before:always'>
<H2>Использование реестра Windows</H2>

<P>Напрямую с реестром библиотека и пользователь больше не работают.
Информация о системных ресурсах назначенных плате извлекается
драйверами при помощи PnP менеджера Windows. Она хоть и хранится в
реестре, но в служебном формате. Для PCI плат эта информация видна на
вкладке ресурсов для соответствующей платы. Для ISA плат она там
устанавливается. Только тип платы и процессора DSP задаются
посредством INF файла при установке плат. Получить их можно
посредством вызова библиотечной функции GetSlotParam. Изменить
соответственно - изменив INF файл. 
</P>

<br clear=all style='page-break-before:always'>
<H2>Создание своего дистрибутива</H2>

<UL>
	<P>Если Вы написали свое приложение и хотите оформить его в виде
	дистрибутива, то включите в него следующие файлы: 
	</P>
	<LI><P>ldevisa.sys - WDM драйвер для ISA плат - копировать в
	WINDOWS\SYSTEM32\DRIVERS;</P>
	<LI><P>ldevpcim.sys - WDM драйвер для PCI плат L791 - копировать в
	WINDOWS\SYSTEM32\DRIVERS;</P>
	<LI><P>ldevpci.sys - WDM драйвер для PCI плат - копировать в
	WINDOWS\SYSTEM32\DRIVERS;</P>
	<LI><P>ldevusbu.sys - WDM драйвер для USB модулей - копировать в
	WINDOWS\SYSTEM32\DRIVERS;</P>
	<LI><P>ldevs.sys - поддерживающий драйвер - копировать в
	WINDOWS\SYSTEM32\DRIVERS;</P>
	<LI><P>lcardisa.inf - INF файл для ISA плат - копировать в
	WINDOWS\INF;</P>
	<LI><P>lcardpci.inf - INF файл для PCI плат - копировать в
	WINDOWS\INF;</P>
	<LI><P>ldevpcim.inf - INF файл для PCI плат L791 - копировать в
	WINDOWS\INF;</P>
	<LI><P>ldevusbu.inf - INF файл для USB модулей - копировать в
	WINDOWS\INF;</P>
	<LI><P>lcomp.dll - DLL библиотека для работы с платами - класть
	лучше всего в один каталог с приложением;</P>
</UL>
<P>Все это будет работать под операционными системами Windows
2000/XP. Оригинальный скрипт инсталляции написан с помощью бесплатной
программы NSIS(www.nullsoft.com) и прилагается. 
</P>

<br clear=all style='page-break-before:always'>
<H2>Низкоуровневое API драйвера</H2>
<H3>Введение</H3>

<P>Драйвер поддерживает некоторый низкоуровневый интерфейс, с помощью
которого можно управлять платой без использования промежуточной DLL
библиотеки. Все обращения к драйверу выполняются посредством вызова
стандартной функции DeviceIoControl с передачей ей соответствующих
параметров. Предварительно драйвер должен быть открыт с помощью
CreateFile. При завершении работы с драйвером необходимо вызвать
CloseHandle. 
</P>
<P><FONT COLOR="#ff0000">Еще не написано. См. исходники библиотеки,
если есть необходимость. </FONT>
</P>

<br clear=all style='page-break-before:always'>
<H2>Описание API DLL библиотеки</H2>
<H3>Введение</H3>

<P>Библиотека функций создана для того, чтобы упростить связь
приложений с драйверами. Ниже приведен полный список функций
поддерживаемых библиотекой - фактически это файл ifc_ldev.h. Работа с
библиотекой построена на принципах COM-интерфейса, но это не COM в
полном смысле этого слова. Для всех плат функции имеют одно и тоже
название. Те из них, которые не поддерживаются конкретной платой,
возвращают статус L_NOTSUPPOTRED. Трактовка параметров в некоторых
функциях различается для конкретных типов плат, о чем написано в
описании функции. 
</P>
<PRE><FONT COLOR="#0000ff">struct LUnknown</FONT>
<FONT COLOR="#0000ff">{</FONT>
<FONT COLOR="#0000ff">   IFC(HRESULT)   QueryInterface(const IID&amp; iid, void** ppv) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)     AddRef() = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)     Release() = 0;</FONT>
<FONT COLOR="#0000ff">};</FONT>

<FONT COLOR="#0000ff">struct IDaqLDevice:LUnknown</FONT>
<FONT COLOR="#0000ff">{</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  inbyte ( ULONG offset, PUCHAR data, ULONG len=1, ULONG key=0) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  inword ( ULONG offset, PUSHORT data, ULONG len=2, ULONG key=0) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  indword( ULONG offset, PULONG data, ULONG len=4, ULONG key=0) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  outbyte ( ULONG offset, PUCHAR data, ULONG len=1, ULONG key=0) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  outword ( ULONG offset, PUSHORT data, ULONG len=2, ULONG key=0) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  outdword( ULONG offset, PULONG data, ULONG len=4, ULONG key=0) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  inmbyte ( ULONG offset, PUCHAR data, ULONG len=1, ULONG key=0) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  inmword ( ULONG offset, PUSHORT data, ULONG len=2, ULONG key=0) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  inmdword( ULONG offset, PULONG data, ULONG len=4, ULONG key=0) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  outmbyte ( ULONG offset, PUCHAR data, ULONG len=1, ULONG key=0) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  outmword ( ULONG offset, PUSHORT data, ULONG len=2, ULONG key=0) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  outmdword( ULONG offset, PULONG data, ULONG len=4, ULONG key=0) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  GetWord_DM(USHORT Addr, PUSHORT Data) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  PutWord_DM(USHORT Addr, USHORT Data) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  PutWord_PM(USHORT Addr, ULONG Data) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  GetWord_PM(USHORT Addr, PULONG Data) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  GetArray_DM(USHORT Addr, ULONG Count, PUSHORT Data) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  PutArray_DM(USHORT Addr, ULONG Count, PUSHORT Data) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  PutArray_PM(USHORT Addr, ULONG Count, PULONG Data) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  GetArray_PM(USHORT Addr, ULONG Count, PULONG Data) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  SendCommand(USHORT Cmd) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  PlataTest() = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  GetSlotParam(PSLOT_PAR slPar) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(HANDLE) OpenLDevice() = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  CloseLDevice() = 0;</FONT>
<FONT COLOR="#0000ff">   </FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  SetParametersStream(PDAQ_PAR sp, ULONG *UsedSize, void** Data, void** Sync, ULONG StreamId = L_STREAM_ADC) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  RequestBufferStream(ULONG *Size, ULONG StreamId = L_STREAM_ADC) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  FillDAQparameters(PDAQ_PAR sp) = 0;  </FONT>

<FONT COLOR="#0000ff">   IFC(ULONG)  InitStartLDevice() = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  StartLDevice() = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  StopLDevice() = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  LoadBios(char *FileName) = 0;</FONT>
<FONT COLOR="#0000ff">   </FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  IoAsync(PDAQ_PAR sp) =0;</FONT>
<FONT COLOR="#0000ff">   </FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  ReadPlataDescr(LPVOID pd) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  WritePlataDescr(LPVOID pd, USHORT Ena) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  ReadFlashWord(USHORT FlashAddress, PUSHORT Data) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  WriteFlashWord(USHORT FlashAddress, USHORT FlashWord) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  EnableFlashWrite(USHORT Flag) = 0;</FONT>
<FONT COLOR="#0000ff">   </FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  EnableCorrection(USHORT Ena=1) = 0;</FONT>
<FONT COLOR="#0000ff">   </FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  GetParameter(ULONG name, PULONG param) = 0;</FONT>
<FONT COLOR="#0000ff">   IFC(ULONG)  SetParameter(ULONG name, PULONG param) = 0;</FONT>
<FONT COLOR="#0000ff">};</FONT></PRE>

<br clear=all style='page-break-before:always'>
<H3>CreateInstance</H3>

<P>Функция создает объект для конкретного слота. Тип объекта
определяется автоматически внутри этой функции. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>LUnknown* CreateInstance(ULONG
   Slot); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
   CreateInstance(Slot:ULONG): LUnknown; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>ULONG Slot </B>- номер слота, для которого создается объект
   (0,1 ...). 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P>- указатель на объект типа LUnknown или NULL в случае ошибки. 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 E14-440 E14-140 E20-10 E154</FONT>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Дополнительную информацию о типе ошибки можно получить вызвав
GetLastError. Если она вернула L_ERROR_NOBOARD значит в запрашиваемом
слоте нет платы. L_ERROR_INUSE - плата в этом слоте уже используется
кем-то. L_ERRROR - возвращается когда невозможно создать объект.
L_NOTSUPPORTED - если в слоте установлена плата, которая не
поддерживается этой библиотекой. Пример использования этой функции
при сканировании слотов см. L1221.DSK.<BR>После вызова CreateInstance
надо вызвать QueryInteface для получения указателя на интерфейс с
которым дальше работать. 
</P>

<br clear=all style='page-break-before:always'>
<H3>Подключение и работа с библиотекой  (на CPP)</H3>

<P>Общий принцип работы с библиотекой: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">Загрузить библиотеку с помощью
	LoadLibrary. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Создать объект, связанный с
	конкретным виртуальным слотом при помощи вызова CreateInstance. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Получить указатель на интерфейс
	вызвав QueryInterface 
	</P>
	<LI><P>Далее вызывать функции этого интерфейса. 
	</P>
</UL>
<P>Виртуальные слоты это собственно порядковые числа в названиях
линков драйверов. Начинаются с 0 и так далее по порядку. Разделения
на ISA,PCI или USB  платы нет. Причем определить, что за плата
соответствует конкретному слоту, можно только открыв его и прочитав
информацию GetSlotParam и ReadPlataDescr (+ для L1450, E440, E2010
предварительно надо загрузить плату). GetSlotParam даст информацию о
типе платы и назначенных ей ресурсах. Далее для PCI плат более
подробную информацию даст ReadPlataDescr. Для L-1450, E440, E2010
также можно вызвать ReadPlataDescr, но предварительно в нее надо
загрузить БИОС.  Вызов ReadPlataDescr обязателен перед началом
конфигурирования сбора данных  поскольку там содержится информация о
частоте кварца необходимая при расчетах временных параметров сбора
данных. Также там хранятся калибровочный коэффициенты.</P>
<P>Для одной платы начало работы выглядит примерно так: 
</P>
<P>Файл create.h 
</P>
<PRE><FONT COLOR="#0000ff">#ifndef __TEST__</FONT>
<FONT COLOR="#0000ff">#define __TEST__</FONT>

<FONT COLOR="#0000ff">typedef IDaqLDevice* (*CREATEFUNCPTR)(ULONG Slot);</FONT>

<FONT COLOR="#0000ff">ULONG CallCreateInstance(char* name);</FONT>

<FONT COLOR="#0000ff">extern CREATEFUNCPTR CreateInstance;</FONT>

<FONT COLOR="#0000ff">#endif</FONT></PRE><P>
Файл create.cpp 
</P>
<PRE><FONT COLOR="#0000ff">#include &lt;windows.h&gt;</FONT>
<FONT COLOR="#0000ff">#include &lt;objbase.h&gt;</FONT>
<FONT COLOR="#0000ff">#include &quot;..\include\ioctl.h&quot;</FONT>
<FONT COLOR="#0000ff">#include &quot;..\include\ifc_ldev.h&quot;</FONT>
<FONT COLOR="#0000ff">#include &quot;..\include\create.h&quot;</FONT>

<FONT COLOR="#0000ff">CREATEFUNCPTR CreateInstance;</FONT>

<FONT COLOR="#0000ff">ULONG CallCreateInstance(char* name)</FONT>
<FONT COLOR="#0000ff">{</FONT>
<FONT COLOR="#0000ff">   HINSTANCE hComponent = ::LoadLibrary(name);</FONT>
<FONT COLOR="#0000ff">   if(hComponent==NULL)</FONT>
<FONT COLOR="#0000ff">   {</FONT>
<FONT COLOR="#0000ff">      return 0;</FONT>
<FONT COLOR="#0000ff">   }</FONT>

<FONT COLOR="#0000ff">   CreateInstance = (CREATEFUNCPTR)::GetProcAddress(hComponent,&quot;CreateInstance&quot;);</FONT>
<FONT COLOR="#0000ff">   if(CreateInstance==NULL)</FONT>
<FONT COLOR="#0000ff">   {</FONT>
<FONT COLOR="#0000ff">      return 0;</FONT>
<FONT COLOR="#0000ff">   }</FONT>
<FONT COLOR="#0000ff">   return 1;</FONT>
<FONT COLOR="#0000ff">}</FONT></PRE><P>
Где-то в Вашем проекте (в компьютере одна плата L-783): 
</P>
<PRE><FONT COLOR="#0000ff">   ULONG slot = 0;</FONT>

<FONT COLOR="#0000ff">   trace(&quot;Get IUnknown pointer&quot;);</FONT>
<FONT COLOR="#0000ff">   CallCreateInstance(&quot;lcomp.dll&quot;);</FONT>
<FONT COLOR="#0000ff">   LUnknown* pIUnknown = CreateInstance(slot);</FONT>
<FONT COLOR="#0000ff">   if(pIUnknown == NULL) { trace(&quot;CallCreateInstance failed&quot;); return 1; }</FONT>
<FONT COLOR="#0000ff">   </FONT>
<FONT COLOR="#0000ff">   trace(&quot;Get IDaqLDevice interface&quot;);</FONT>
<FONT COLOR="#0000ff">   IDaqLDevice* pI;</FONT>
<FONT COLOR="#0000ff">   HRESULT hr = pIUnknown-&gt;QueryInterface(IID_ILDEV,(void**)&amp;pI);</FONT>
<FONT COLOR="#0000ff">   if(!SUCCEEDED(hr)) { trace(&quot;Get IDaqLDevice failed&quot;); return 1; }</FONT>
<FONT COLOR="#0000ff">   trace(&quot;IDaqLDevice get success&quot;);</FONT>
<FONT COLOR="#0000ff">   trace(&quot;Free IUnknown&quot;);</FONT>
<FONT COLOR="#0000ff">   pIUnknown-&gt;Release();</FONT>

<FONT COLOR="#0000ff">   pI-&gt;OpenLDevice(); // начало работы с платой</FONT>
<FONT COLOR="#0000ff">   pI-&gt;LoadBios(&quot;l783&quot;);</FONT>
<FONT COLOR="#0000ff">   ...</FONT>

<FONT COLOR="#0000ff">   pI-&gt;CloseLDevice(); // завершение работы</FONT>
<FONT COLOR="#0000ff">   pI-&gt;Release();</FONT></PRE><P>
Подробнее - смотрите примеры. 
</P>

<br clear=all style='page-break-before:always'>
<H3>Подключение и работа с библиотекой  (на Pascal/Delphi)</H3>

<P>Общий принцип работы с библиотекой: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">Загрузить библиотеку с помощью
	LoadLibrary. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Создать объект, связанный с
	конкретным виртуальным слотом при помощи вызова CreateInstance. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Получить указатель на интерфейс,
	вызвав QueryInterface 
	</P>
	<LI><P>Далее вызывать функции этого интерфейса. 
	</P>
</UL>
<P>Виртуальные слоты это собственно порядковые числа в названиях
линков драйверов. Начинаются с 0 и так далее по порядку. Разделения
на ISA,PCI или USB платы нет. Причем определить, что за плата
соответствует конкретному слоту, можно только открыв его и прочитав
информацию GetSlotParam и ReadPlataDescr (+ для L1450, E440, E2010
предварительно надо загрузить плату). GetSlotParam даст информацию о
типе платы и назначенных ей ресурсах. Далее для PCI плат более
подробную информацию даст ReadPlataDescr. Для L-1450, E440, E2010
также можно вызвать ReadPlataDescr, но предварительно в нее надо
загрузить БИОС.  Вызов ReadPlataDescr обязателен перед началом
конфигурирования сбора данных  поскольку там содержится информация о
частоте кварца необходимая при расчетах временных параметров сбора
данных. Также там хранятся калибровочный коэффициенты.. 
</P>
<P>Для одной платы начало работы выглядит примерно так: 
</P>
<P>Файл create.pas 
</P>
<PRE><FONT COLOR="#0000ff">unit Create;</FONT>

<FONT COLOR="#0000ff">interface</FONT>

<FONT COLOR="#0000ff">uses Windows, ioctl, ifc_ldev;</FONT>

<FONT COLOR="#0000ff">type</FONT>
<FONT COLOR="#0000ff">  TCreateInstance = function(Slot:ULONG): LUnknown; cdecl;</FONT>

<FONT COLOR="#0000ff">var</FONT>
<FONT COLOR="#0000ff">  hModule: THandle;</FONT>
<FONT COLOR="#0000ff">  CreateInstance: TCreateInstance;</FONT>

<FONT COLOR="#0000ff">  function CallCreateInstance(name:PChar):ULONG;</FONT>

<FONT COLOR="#0000ff">implementation</FONT>

<FONT COLOR="#0000ff">function CallCreateInstance(name:PChar):ULONG;</FONT>
<FONT COLOR="#0000ff">begin</FONT>
<FONT COLOR="#0000ff">   hModule:=0;</FONT>
<FONT COLOR="#0000ff">   hModule:=LoadLibrary(name);</FONT>
<FONT COLOR="#0000ff">   if(hModule=0) then</FONT>
<FONT COLOR="#0000ff">   begin</FONT>
<FONT COLOR="#0000ff">      Result:=0;</FONT>
<FONT COLOR="#0000ff">      Exit;</FONT>
<FONT COLOR="#0000ff">   end;</FONT>
<FONT COLOR="#0000ff">   @CreateInstance:=GetProcAddress(hModule,'CreateInstance');</FONT>
<FONT COLOR="#0000ff">   if(@CreateInstance=nil) then</FONT>
<FONT COLOR="#0000ff">   begin</FONT>
<FONT COLOR="#0000ff">      Result:=0;</FONT>
<FONT COLOR="#0000ff">      Exit;</FONT>
<FONT COLOR="#0000ff">   end;</FONT>
<FONT COLOR="#0000ff">   Result:=1;</FONT>
<FONT COLOR="#0000ff">end;</FONT>

<FONT COLOR="#0000ff">end.</FONT></PRE><P>
Где-то в Вашем проекте (в компьютере одна плата L-1450): 
</P>
<PRE><FONT COLOR="#0000ff">var</FONT>
<FONT COLOR="#0000ff">  pLDev: IDaqLDevice;</FONT>
<FONT COLOR="#0000ff">  pIUnknown:LUnknown;</FONT>
<FONT COLOR="#0000ff">  hr:Integer;</FONT>
<FONT COLOR="#0000ff">  dev: THandle;</FONT>

<FONT COLOR="#0000ff">   ...</FONT>
<FONT COLOR="#0000ff">   if(CallCreateInstance('lcomp.dll')=1) then</FONT>
<FONT COLOR="#0000ff">   begin</FONT>
<FONT COLOR="#0000ff">      {сообщение об успехе загрузки библиотеки}</FONT>
<FONT COLOR="#0000ff">   end;</FONT>

<FONT COLOR="#0000ff">   pIUnknown:=CreateInstance(0);</FONT>
<FONT COLOR="#0000ff">   hr := pIUnknown.QueryInterface(IID_ILDEV,pLDev);</FONT>
<FONT COLOR="#0000ff">   if(not Succeeded(hr)) then MessageBox(0,'Get interface failed','Error',MB_OK);</FONT>
<FONT COLOR="#0000ff">   pIUnknown.Release;</FONT>
<FONT COLOR="#0000ff">   dev:=pLDev.OpenLDevice;</FONT>
<FONT COLOR="#0000ff">   ...</FONT>
<FONT COLOR="#0000ff">   </FONT>
<FONT COLOR="#0000ff">   pLDev.CloseLDevice;</FONT>
<FONT COLOR="#0000ff">   pLDev.Release;</FONT>
<FONT COLOR="#0000ff">   </FONT></PRE><P>
Подробнее - смотрите примеры. 
</P>

<br clear=all style='page-break-before:always'>
<H3>Основные функции</H3>
<H4>OpenLDevice</H4>

<P>Эту функцию необходимо вызвать перед началом работы с платой.
Функция открывает соответствующий линк драйвера для платы. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>HANDLE OpenLDevice(); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function OpenLDevice:THandle; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>HANDLE </B>- в случае успеха (дескриптор для работы с платой);
   <BR><B>INVALID_HANDLE_VALUE </B>- в случае ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Для каждой платы установленной в компьютер драйвер формирует линк
по следующему принципу: LDev## (где ## - номер 1..).Номер в названии
линка - это виртуальный слот. Номер виртуального слота, для которого
будет выполнена функция OpenLDevice, передается как параметр в
функции CreateInstance. 
</P>

<br clear=all style='page-break-before:always'>
<H4>CloseLDevice</H4>

<P>Эта функция вызывается при завершении работы с платой. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG CloseLDevice(); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function CloseLDevice:ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>После вызова этой функции значение дескриптора устройства больше
недействительно и не может использоваться при вызове функций
библиотеки. Для платы L791 еще происходит удаление выделенной в
функции RequsetBufferStream памяти для буфера ПДП.</P>

<br clear=all style='page-break-before:always'>
<H4>SetParametersStream</H4>

<P>Вызов этой функции настраивает плату АЦП/ЦАП на заданные параметры
ввода или вывода данных, устанавливает размера кольцевого буфера на
плате, задает интервал генерации прерываний (через столько-то точек),
передает приложению адреса большого буфера и переменой синхронизации.
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG
   SetParametersStream(PDAQ_PAR sp, ULONG *UsedSize, void** Data,
   void** Sync, ULONG StreamId); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function SetParametersStream(var sp:DAQ_PAR; var UsedSize:ULONG;
   out Data; out Sync; StreamId:ULONG):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>PDAQ_PAR sp </B>- структура, которая описывает параметры ввода
   или вывода данных ( ADC_PAR,DAC_PAR или другая в зависимости от типа
   поля s_Type); <BR><B>ULONG *UsedSize </B>- переменная, в которой
   будет возвращено количество реально используемой памяти (в отсчетах
   АЦП); <BR><B>void** Data </B>- переменная, в которой будет возвращен
   адрес начала большого буфера; <BR><B>void** Sync </B>- переменная, в
   которой будет возвращен адрес переменной синхронизации; <BR><B>ULONG
   StreamId </B>- дескриптор потока (L_STREAM_ADC, L_STREAM_DAC или
   другой); 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; <BR><B>PDAQ_PAR sp </B>- структура, которая описывает
   параметры ввода или вывода данных. У этой структуры, если она не
   NULL, обновляются поля с учетом возможностей платы. 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Принцип быстрого и непрерывного ввода или вывода данных с платы в
драйверах всегда одинаков. Различается только направление передачи
данных. Поэтому было введено понятие потоков данных. Поток создается
3 функциями - RequestBufferStream FullDAQparameters
SetParametersStream. Фактически это большой кольцевой буфер и
структура, описывающая параметры сбора данных. Поток может быть с
АЦП, на ЦАП, на цифровые линии, с цифровых линий или какой-то
нестандартный реализованный в драйвере платы. Интерфейс при этом не
меняется. Чтобы различать потоки служит переменная StreamId - это
некоторая константа, определенная в заголовочных файлах. 
</P>

<br clear=all style='page-break-before:always'>
<H4>RequestBufferStream</H4>

<P>Функция служит для выделения памяти под большой кольцевой буфер. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG
   RequestBufferStream(ULONG *Size, ULONG StreamId); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function RequestBufferStream(var Size:ULONG;
   StreamId:ULONG):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>ULONG *Size </B>- размер большого буфера в USHORT; <BR><B>ULONG
   StreamId </B>- дескриптор потока (L_STREAM_ADC, L_STREAM_DAC или
   другой); 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; <BR><B>Size </B>- возвращается количество реально выделенной
   памяти; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Выделяет память в ОЗУ компьютера под большой кольцевой буфер.
Память выделяется с выравниванием размера на 4096 байт. Принцип
быстрого и непрерывного ввода или вывода данных с платы в драйверах
всегда одинаков. Различается только направление передачи данных.
Поэтому было введено понятие потоков данных. Поток создается 3
функциями - RequestBufferStream SetParametersStream
FullDAQparameters. Фактически это большой кольцевой буфер и
структура, описывающая параметры сбора данных. Поток может быть с
АЦП, на ЦАП, на цифровые линии, с цифровых линий или какой-то
нестандартный реализованный в драйвере платы. Интерфейс при этом не
меняется. Чтобы различать потоки служит переменная StreamId - это
некоторая константа, определенная в заголовочных файлах. 
</P>
<P>Для платы L791 выделяется всегда 512*1024 слов. Это буфер отсчетов
ЦАП и АЦП - по 128К 32 битных отсчетов соответственно. Удаляется этот
буффер при вызове CloseLDevice .</P>
<P><BR><BR>
</P>

<br clear=all style='page-break-before:always'>
<H4>InitStartLDevice</H4>

<P>Функция инициализирует внутренние переменные драйвера перед
началом сбора. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG InitStartLDevice();
   </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
   InitStartLDevice:ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Надо вызывать перед вызовом функции StartLDevice. 
</P>

<br clear=all style='page-break-before:always'>
<H4>StartLDevice</H4>

<P>Функция запускает сбор данных с платы в большой кольцевой буфер. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG StartLDevice(); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function StartLDevice:ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>После выполнения функции можно переходить к откачиванию данных из
буфера. При этом необходимо следить за синхронизацией поступления
данных и их откачки. 
</P>

<br clear=all style='page-break-before:always'>
<H4>StopLDevice</H4>

<P>Функция останавливает сбор данных с платы в большой кольцевой
буфер. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG StopLDevice(); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function StopLDevice:ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>После остановки данные в буфере соответствуют последним данным,
полученным от платы. Их можно обрабатывать любым способом. Необходимо
только учитывать, что остановка могла произойти в любом месте этого
буфера и гарантировать целостность можно только той части буфера, на
готовность которой указывала переменная синхронизации. 
</P>
<P>Для L791 не следует пытаться разрешить режим BusMaster после
выполнения команды StopLDevice. При старте буфер данных блокируется в
ОЗУ компьютера, формируется таблица адресов и передается в плату. При
остановке блокировка снимается и разрешение на передачу данных
вызовет повреждение операционной системы.</P>

<br clear=all style='page-break-before:always'>
<H4>LoadBios</H4>

<P>Загрузка BIOS в плату. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG LoadBios(char
   *FileName); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
   LoadBios(FileName:PChar):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>char *FileName </B>- имя файла прошивки БИОС без расширения
   (lbios009); 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 E14-440 E20-10</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P><FONT COLOR="#000000">В модуль E20-10 загружается прошивка ПЛИС
<B>e2010.pld</B>, указывать ее нужно также без расширения. У L791 нет
загружаемого БИОСа. E140 также не требует загрузки БИОС.</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>GetWord_DM</H4>

<P>Читает слово из памяти данных DSP. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG GetWord_DM(USHORT Addr,
   PUSHORT Data); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
   GetWord_DM(Addr:USHORT; var Data:USHORT):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT Addr </B>- адрес переменной; <BR><B>PUSHORT Data </B>-
   возвращаемые данные; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; <BR><B>PUSHORT Data </B>- возвращаемые данные; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L305 L264 L1450 L1221 E14-440 E14-140 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>PutWord_DM</H4>

<P>Записывает слово в память данных DSP. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG PutWord_DM(USHORT Addr,
   USHORT Data); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
   PutWord_DM(Addr:USHORT; Data:USHORT):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT Addr </B>- адрес переменной; <BR><B>USHORT Data </B>-
   записываемые данные; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L305 L264 L1450 L1221 E14-440 E14-140 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>GetWord_PM</H4>

<P>Читает слово из памяти программ DSP. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG GetWord_PM(USHORT Addr,
   PULONG Data); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
   GetWord_PM(Addr:USHORT; var Data:ULONG):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT Addr </B>- адрес переменной; <BR><B>PULONG Data </B>-
   возвращаемые данные; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; <BR><B>PULONG Data </B>- возвращаемые данные; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1450 L1221 E14-440 E14-140 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>PutWord_PM</H4>

<P>Читает слово из памяти программ DSP. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG PutWord_PM(USHORT Addr,
   ULONG Data); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
   PutWord_PM(Addr:USHORT; Data:ULONG):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT Addr </B>- адрес переменной; <BR><B>ULONG Data </B>-
   записываемые данные; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1450 L1221 E14-440 E14-140 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>GetArray_DM</H4>

<P>Читает массив слов из памяти данных DSP. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG GetArray_DM(USHORT Addr,
   ULONG Count, PUSHORT Data); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function GetArray_DM(Addr:USHORT; Count:ULONG; var
   Data:USHORT):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT Addr </B>- адрес переменной; <BR><B>ULONG Count </B>-
   размер массива в словах; <BR><B>PUSHORT Data </B>- возвращаемые
   данные; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; <BR><B>PUSHORT Data </B>- возвращаемые данные; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1450 L1221 E14-440 E14-140 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>PutArray_DM</H4>

<P>Записывает массив слов в память данных DSP. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG PutWord_DM(USHORT Addr,
   ULONG Count, USHORT Data); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function PutWord_DM(Addr:USHORT; Count:ULONG; Data:USHORT):ULONG;
   </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT Addr </B>- адрес переменной; <BR><B>ULONG Count </B>-
   размер массива в словах; <BR><B>USHORT Data </B>- записываемые
   данные; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1450 L1221 E14-440 E14-140 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>GetArray_PM</H4>

<P>Читает массив слов из памяти программ DSP. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG GetArray_PM(USHORT Addr,
   ULONG Count, PULONG Data); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function GetArray_PM(Addr:USHORT; Count:ULONG; var
   Data:ULONG):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT Addr </B>- адрес переменной; <BR><B>ULONG count </B>-
   размер массива в двойных словах; <BR><B>PULONG Data </B>-
   возвращаемые данные; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; <BR><B>PULONG Data </B>- возвращаемые данные; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1450 L1221 E14-440</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>PutArray_PM</H4>

<P>Записывает массив слов в память программ DSP. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG PutArray_PM(USHORT Addr,
   ULONG Count, ULONG Data); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function PutArray_PM(Addr:USHORT; Count:ULONG; Data:ULONG):ULONG;
   </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT Addr </B>- адрес переменной; <BR><B>ULONG Count </B>-
   размер массива в двойных словах; <BR><B>ULONG Data </B>-
   записываемые данные; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1450 L1221 E14-440</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>SendCommand</H4>

<P>Посылает выбранную команду DSP. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG SendCommand(USHORT Cmd)
   ; </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
   SendCommand(Cmd:USHORT):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT Cmd </B>- код команды; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L264 L305 L1450 L1221 E14-440 E14-140 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>PlataTest</H4>

<P>Тест на наличие платы и успешную загрузку. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG PlataTest(); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function PlataTest:ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P><FONT COLOR="#000000">Для L791, E14-140 E154и E20-10 это просто заглушка
всегда возвращающая успех.</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>IoAsync</H4>

<P>Функция для асинхронных операций ввода/вывода (чтение данных с
АЦП, вывод данных на ЦАП, работа с цифровыми линиями). 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG IoAsync(PDAQ_PAR sp);
	</B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function IoAsync(var
	sp:DAQ_PAR):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>PDAQ_PAR sp </B>- структура с параметрами запроса; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; <BR><B>PDAQ_PAR sp </B>- структура с результатами запроса
	(если была операция ввода данных); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 L791
	E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Эта функция реализует все асинхронные операции ввода/вывода (типа
одиночного ввода данных). 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>Плата L-1450</B> 
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с АЦП
		надо заполнить структуру ASYNC_PAR так:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_ADC_INP<BR><B>Chn[0]</B>
		- логический номер канала;<BR>Результат в <B>Data[0]</B>. 
		</P>
	</UL>
</UL>
<UL>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на TTL
		линии:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_OUT<BR><B>Data[0]</B> - данные для вывода; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с TTL
		линий:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_INP<BR><B>Data[0]</B> - введенные данные; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Разрешить/запретить цифровые
		линии:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_TTL_CFG<BR><B>Mode</B>
		- (0/1); 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на ЦАП:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_DAC_OUT<BR><B>Mode</B>
		- (0/1) номер ЦАП;<BR><B>Data[0]</B> - данные для ЦАП; 
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>Платы L-1250/L-264/L-305/L-1620</B>
		</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с АЦП
		надо заполнить структуру ASYNC_PAR так:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_ADC_INP<BR><B>Chn[0]</B>
		- логический номер канала;<BR>Результат в <B>Data[0]</B>. 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на TTL
		линии:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_OUT<BR><B>Data[0]</B> - данные для вывода;<BR><B>Mode</B>
		- (0 - for multiplexer ttl(SETCHANNEL in fact))/( 1- dsp out) 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с TTL
		линий:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_TTL_INP<BR><B>Mode</B>
		- (0 - прямые линии)/(1 - линии через DSP)<BR><B>Data[0]</B> -
		введенные данные; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на ЦАП:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_DAC_OUT<BR><B>Mode</B>
		- (0 - синхронный/1 - асинхронный) вывод на ЦАП;<BR><B>Data[0]</B>
		- данные для ЦАП; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для установки номера ЦАП и режима
		вывода:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_DAC_CFG<BR><B>Mode</B>
		- (0 - выкл режим одновременного вывода )(1 - вкл режим
		одновременного вывода на ЦАП со вводом с АЦП);<BR><B>Chn[0]</B> -
		номер ЦАП(0/1); 
		</P>
		<LI><P STYLE="margin-bottom: 0cm"></P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>Плата L-1221</B> 
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с АЦП
		надо заполнить структуру ASYNC_PAR так:</P>
		<P STYLE="margin-bottom: 0cm">s_Type -L_ASYNC_ADC_INP<BR><B>Chn[0]
		</B>- логический номер канала;<BR>Результат в <B>Data[0]</B>.</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на TTL
		линии:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_OUT<BR><B>Data[0]</B> - данные для вывода; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с TTL
		линий:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_INP<BR><B>Data[0]</B> - введенные данные; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для настройки цифровых линий:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_TTL_CFG<BR><B>Mode</B>
		- маска направлений (0XXX 0000) 
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>Платы L-761/L-780/L-783</B> 
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с АЦП
		надо заполнить структуру ASYNC_PAR так:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_ADC_INP<BR><B>Chn[0]</B>
		- логический номер канала;<BR>Результат в <B>Data[0]</B>.</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на TTL
		линии:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_OUT<BR><B>Data[0]</B> - данные для вывода; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с TTL
		линий:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_INP<BR><B>Data[0]</B> - введенные данные; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на ЦАП:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_DAC_OUT<BR><B>Mode</B>
		- номер ЦАП (0/1);<BR><B>Data[0]</B> - данные для ЦАП; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Разрешить/запретить цифровые
		линии: (только L780C)</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_TTL_CFG<BR><B>Mode</B>
		- (0/1); 
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>Платы L-791</B> 
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с АЦП
		надо заполнить структуру ASYNC_PAR так:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_ADC_INP<BR><B>Chn[0]</B>
		- логический номер канала;<BR>Результат в <B>Data[0]</B>.</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода отсчета на ЦАП надо
		заполнить структуру ASYNC_PAR так:</P>
		<P STYLE="margin-bottom: 0cm">s_Type -L_ASYNC_DAC_OUT</P>
		<P STYLE="margin-bottom: 0cm">Chn[0] -(0/1) выводить на 0 канал</P>
		<P STYLE="margin-bottom: 0cm">Chn[1] -(0/1) выводить на 1 канал</P>
		<P STYLE="margin-bottom: 0cm">Data[0] &mdash; данные для 0 канала</P>
		<P STYLE="margin-bottom: 0cm">Data[1] &mdash; данные для 1 канала</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на TTL
		линии:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_OUT<BR><B>Data[0]</B> - данные для вывода;</P>
	</UL>
</UL>
<UL>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с TTL
		линий:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_INP<BR><B>Data[0]</B> - введенные данные; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Разрешить/запретить цифровые
		линии:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_TTL_CFG<BR><B>Mode</B>
		&ndash; (0/1) разрешить/запретить цифровые линии; 
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>Модуль E440</B></P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с АЦП
		надо заполнить структуру ASYNC_PAR так:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_ADC_INP<BR><B>Chn[0]</B>
		- логический номер канала;<BR>Результат в <B>Data[0]</B>.</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на TTL
		линии:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_OUT<BR><B>Data[0]</B> - данные для вывода;</P>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с TTL
		линий:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_INP<BR><B>Data[0]</B> - введенные данные; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на ЦАП:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_DAC_OUT<BR><B>Mode</B>
		- номер ЦАП (0/1);<BR><B>Data[0]</B> - данные для ЦАП; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Разрешить/запретить цифровые
		линии:</P>
		<P STYLE="margin-bottom: 0cm; font-weight: medium"><B>s_Type</B>
		-L_ASYNC_TTL_CFG<BR><B>Mode</B> - (0/1); 
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>Модуль E140</B></P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с АЦП
		надо заполнить структуру ASYNC_PAR так:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_ADC_INP<BR><B>Chn[0]</B>
		- логический номер канала;<BR>Результат в <B>Data[0]</B>. 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на TTL
		линии:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_OUT<BR><B>Data[0]</B> - данные для вывода; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с TTL
		линий:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_INP<BR><B>Data[0]</B> - введенные данные; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на ЦАП:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_DAC_OUT<BR><B>Mode</B>
		- номер ЦАП (0/1);<BR><B>Data[0]</B> - данные для ЦАП;</P>
		<LI><P STYLE="margin-bottom: 0cm">Разрешить/запретить цифровые
		линии:</P>
		<P STYLE="margin-bottom: 0cm; font-weight: medium"><B>s_Type</B>
		-L_ASYNC_TTL_CFG<BR><B>Mode</B> - (0/1); 
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>Модуль E2010</B></P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на TTL
		линии:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_OUT<BR><B>Data[0]</B> - данные для вывода; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с TTL
		линий:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_INP<BR><B>Data[0]</B> - введенные данные; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на ЦАП:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_DAC_OUT<BR><B>Mode</B>
		- номер ЦАП (0/1);<BR><B>Data[0]</B> - данные для ЦАП;</P>
		<LI><P STYLE="margin-bottom: 0cm">Разрешить/запретить цифровые
		линии:</P>
		<P STYLE="margin-bottom: 0cm; font-weight: medium"><B>s_Type</B>
		-L_ASYNC_TTL_CFG<BR><B>Mode</B> - (0/1); 
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>Модуль E154</B></P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с АЦП
		надо заполнить структуру ASYNC_PAR так:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B> -L_ASYNC_ADC_INP<BR><B>Chn[0]</B>
		- логический номер канала;<BR>Результат в <B>Data[0]</B>. 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на TTL
		линии:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_OUT<BR><B>Data[0]</B> - данные для вывода; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для ввода одного отсчета с TTL
		линий:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_TTL_INP<BR><B>Data[0]</B> - введенные данные; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">Для вывода одного отсчета на ЦАП:</P>
		<P STYLE="margin-bottom: 0cm"><B>s_Type</B>
		-L_ASYNC_DAC_OUT<BR><B>Data[0]</B> - данные для ЦАП;</P>
		<LI><P STYLE="margin-bottom: 0cm">Разрешить/запретить цифровые
		линии:</P>
		<P STYLE="margin-bottom: 0cm; font-weight: medium"><B>s_Type</B>
		-L_ASYNC_TTL_CFG<BR><B>Mode</B> - (0/1); 
		</P>
	</UL>
</UL>
<P STYLE="margin-bottom: 0cm"><BR>
</P>

<br clear=all style='page-break-before:always'>
<H4>EnableCorrection</H4>

<P>Включает/выключает режим коррекции. Сама загружает коэффициенты в
плату. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG EnableCorrection(USHORT
   Ena=1); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
   EnableCorrection(Ena:USHORT):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT Ena </B>- новое значение переменной
   разрешения/запрещения коррекции (1/0); 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1450 L1221 E14-440</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>FillDAQparameters</H4>

<P>Заполняет внутреннюю структуру параметров сбора данных значениями
из структуры ADC_PAR,DAC_PAR или другой в зависимости от типа поля
s_Type. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG
   FillDAQparameters(PDAQ_PAR sp); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function FillDAQparameters(var sp:DAQ_PAR):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>PDAQ_PAR sp </B>- структура с параметрами сбора данных; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; <BR><B>PDAQ_PAR sp </B>- в структуре обновлены поля
   Rate,Kadr,NCh с учетом возможностей платы. 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L305 L264 L1450 L1221 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>ReadPlataDescr</H4>

<P>Чтение пользовательского Flash. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ReadPlataDescr(LPVOID pd);
   </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
   ReadPlataDescr(var pd):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>LPVOID pd </B>- указатель на структуру PLATA_DESCR_U; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; <BR><B>LPVOID pd </B>- указатель на заполненную структуру
   PLATA_DESCR_U; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P><FONT COLOR="#000000">Для каждой платы определены свои частные
структуры флеша и для удобства они сгруппированы в union
PLATA_DESCR_U/U2. U2 появился из-за модуля E2010 у которого флеш 
больше. Внутри библиотеки все хранится в union PLATA_DESCR_U2.</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>WritePlataDescr</H4>

<P>Запись пользовательского Flash. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG WritePlataDescr(LPVOID
   pd, USHORT Ena); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function WritePlataDescr(var pd; Ena:USHORT):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>LPVOID pd </B>- указатель на структуру PLATA_DESCR_U; <BR><B>USHORT
   Ena </B>- разрешение(1) / запрещение(0) записи служебной части
   пользовательского Flash; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>ReadFlashWord</H4>

<P>Чтение слова из пользовательского Flash. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG ReadFlashWord(USHORT
   FlashAddress, PUSHORT Data); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function ReadFlashWord(FlashAddress:USHORT; var
   Data:USHORT):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT FlashAddress </B>- адрес, с которого читать; <BR><B>PUSHORT
   Data </B>- прочитанное слово; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; <BR><B>PUSHORT Data </B>- прочитанное слово; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1450 L1221 L791 E14-440 E14-140</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Для L1221 и L791 читает байт. Старший байт слова не используется.</P>

<br clear=all style='page-break-before:always'>
<H4>WriteFlashWord</H4>

<P>Запись слова в пользовательский Flash. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG WriteFlashWord(USHORT
   FlashAddress, USHORT Data); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function WriteFlashWord(FlashAddress:USHORT; Data:USHORT):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT FlashAddress </B>- адрес, по которому писать; <BR><B>USHORT
   Data </B>- записываемое слово; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1450 L1221 L791 E14-440 E14-140</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Для L1221 записывает младший байт из слова. Для L791 записывает
младший байт из слова в буфер микросхемы. Реальная запись происходит
по команде EnableFlashWrite в указанную страницу.</P>

<br clear=all style='page-break-before:always'>
<H4>EnableFlashWrite</H4>

<P>Разрешение записи в пользовательский Flash. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG EnableFlashWrite(USHORT
   Flag); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
   EnableFlashWrite(Flag:USHORT):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>USHORT Flag </B>- разрешение (1) / запрещение (0) записи во
   Flash; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P><FONT COLOR="#000000">Для платы L791 Flag это номер страницы в
которую будут записаны данные из буфера микросхемы. <B>0</B> - это
страница со структурой PLATA_DESCR.</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>GetParameter</H4>

<P>Функция служит для считывания разнообразных параметров с платы.
Замещает некоторые простые функции из старых API. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG GetParameter(ULONG name,
	PULONG param); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
	GetParameter(name:ULONG; var param:ULONG):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG name </B>- условное название параметра (см примечание);
	<BR><B>PULONG param </B>- значение параметра; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; <BR><B>PULONG param </B>- значение параметра; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L1221 L1250 L264 L305 </FONT>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">Для 1221 есть следующие параметры:
		</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">L1221_EXT_COUNTER - считать
		значение внешнего счетчика (ячейки 0x3D5C 0x3D5B); 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">L1221_OVERFLOW - считать значение
		ячейки переполнения (0x3D4E); 
		</P>
		<LI><P STYLE="margin-bottom: 0cm">L1221_BIT_RES - считать ячейку с
		разрядностью АЦП (0x3D58); 
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm">Для 1250/264/305: 
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">L1251_MEM_STATE - возвращает
		размер установленной внешней памяти данных: 0 - нет; 1 - 8К; 2 -
		32К; 3 - 128К; 
		</P>
		<LI><P>L1251_MEM_PM_STATE - тестирует наличие внешней памяти
		программ на плате: 0 - нет; 1 - есть; 
		</P>
	</UL>
</UL>

<br clear=all style='page-break-before:always'>
<H4>SetParameter</H4>

<P>Функция служит для записи разнообразных параметров в плату.
Замещает некоторые простые функции из старых API. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG SetParameter(ULONG name,
	PULONG param); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
	SetParameter(name:ULONG; var param:ULONG):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG name </B>- условное название параметра (см примечание);
	<BR><B>PULONG param </B>- значение параметра; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; <BR><B>PULONG param </B>- значение параметра; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L1221 </FONT>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Для 1221 есть следующие параметры: 
</P>
<UL>
	<LI><P>L1221_BIT_RES - считать ячейку с разрядностью АЦП (0x3D58); 
	</P>
</UL>

<br clear=all style='page-break-before:always'>
<H4>SetLDeviceEvent</H4>

<P>Функция служит для установки события в драйвере. Работа события
облегчает ожидание готовности данных от платы при однократном
заполнении буфера. Также позволяет более удобно получать информацию о
других процессах в плате.</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG SetLDeviceEvent(HANDLE
   hEvent, ULONG EventId=L_EVENT_ADC); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
   <B>function SetParameter(hEvent:THandle; EventId:ULONG):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>ULONG hEvent </B>- условное название параметра (см
   примечание); <BR><B>ULONG EventId &ndash;</B> идентификатор события
   на который установлен event; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; <BR><BR><BR>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Для EventId есть следующие значения: 
</P>
<UL>
   <LI><P>L_EVENT_ADC_BUF 1 &ndash; событие по заполнении буфера АЦП:</P>
   <LI><P>L_EVENT_DAC_BUF 2 - событие при работе с буфером ЦАП (L1450,
   L780M):</P>
   <LI><P>L_EVENT_ADC_OVF 3 - L791 -см описание по генерации прерываний
   от платы;</P>
   <LI><P>L_EVENT_ADC_FIFO 4 - L791 -см описание по генерации
   прерываний от платы;</P>
   <LI><P>L_EVENT_DAC_USER 5 - L791 -см описание по генерации
   прерываний от платы; 
   </P>
   <LI><P>L_EVENT_DAC_UNF 6 - L791 -см описание по генерации прерываний
   от платы; 
   </P>
   <LI><P>L_EVENT_PWR_OVR 7 - L791 -см описание по генерации прерываний
   от платы; 
   </P>
</UL>

<br clear=all style='page-break-before:always'>
<H3>Вспомогательные функции</H3>
<H4>GetSlotParam</H4>

<P>Функция возвращает информацию для указанного виртуального слота. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG GetSlotParam(PSLOT_PAR
   slPar); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT> <B>function
   GetSlotParam(var slPar:SLOT_PAR):ULONG; </B>
   </P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>PSLOT_PAR slPar </B>- переменная, в которой будут возвращены
   параметры; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
   <P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
   ошибки; <BR><B>PSLOT_PAR slPar </B>- параметры установленные для
   данного слота; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
   <P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 L791 E14-440 E14-140 E20-10 E154</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H3>Функции для работы с портами ввода/вывода</H3>
<H4>inbyte</H4>

<P>Ввод байта из I/O порта. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG inbyte ( ULONG offset,
	PUCHAR data, ULONG len=1, ULONG key=0); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
	<B>function inbyte (offset:ULONG; var data:UCHAR; len:ULONG;
	key:ULONG ):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG offset </B>- смещение порта относительно базового
	адреса; <BR><B>PUCHAR data </B>- массив, в который будут занесены
	прочитанные данные; <BR><B>ULONG len </B>- размер массива в байтах;
	<BR><B>ULONG key </B>- номер региона ( фактически выбирает базовый
	адрес из списка возможных ); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
ошибки; <BR><B>PUCHAR data </B>- прочитанные данные; 
</P>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L1221 L1250 L264 L305 L1450 </FONT>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>В данной реализации нет проверки выхода смещения за разрешенную
границу. Про key. У некоторых плат есть несколько регионов портов
ввода/вывода. Для переключения между ними и служит этот параметр.
Например при key=0 для L7XX будет осуществляться доступ к служебным
регистрам PLX, а при key=1 к DSP(те работа через порты, а не память).
В стандартных драйверах этот параметр не задействован и должен быть
всегда равен 0. 
</P>

<br clear=all style='page-break-before:always'>
<H4>inword</H4>

<P>Ввод слова из I/O порта. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG inword ( ULONG offset,
	PUSHORT data, ULONG len=2, ULONG key=0); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
	<B>function inword (offset:ULONG; var data:USHORT; len:ULONG;
	key:ULONG ):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG offset </B>- смещение порта относительно базового
	адреса; <BR><B>PUSHORT data </B>- массив, в который будут занесены
	прочитанные данные; <BR><B>ULONG len </B>- размер массива в байтах;
	<BR><B>ULONG key </B>- номер региона ( фактически выбирает базовый
	адрес из списка возможных ); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; <BR><B>PUSHORT data </B>- прочитанные данные; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L1221 L1250 L264 L305 L1450 </FONT>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>В данной реализации нет проверки выхода смещения за разрешенную
границу. Про key. У некоторых плат есть несколько регионов портов
ввода/вывода. Для переключения между ними и служит этот параметр.
Например, при key=0 для L7XX будет осуществляться доступ к служебным
регистрам PLX, а при key=1 к DSP(те работа через порты, а не память).
В стандартных драйверах этот параметр не задействован и должен быть
всегда равен 0. 
</P>

<br clear=all style='page-break-before:always'>
<H4>indword</H4>

<P>Ввод двойного слова из I/O порта. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG indword ( ULONG offset,
	PULONG data, ULONG len=4, ULONG key=0); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
	<B>function indword (offset:ULONG; var data:ULONG; len:ULONG;
	key:ULONG ):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG offset </B>- смещение порта относительно базового
	адреса; <BR><B>PULONG data </B>- массив, в который будут занесены
	прочитанные данные; <BR><B>ULONG len </B>- размер массива в байтах;
	<BR><B>ULONG key </B>- номер региона ( фактически выбирает базовый
	адрес из списка возможных ); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; <BR><B>PULONG data </B>- прочитанные данные; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L1221 L1250 L264 L305 L1450 </FONT>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>В данной реализации нет проверки выхода смещения за разрешенную
границу. Про key. У некоторых плат есть несколько регионов портов
ввода/вывода. Для переключения между ними и служит этот параметр.
Например, при key=0 для L7XX будет осуществляться доступ к служебным
регистрам PLX, а при key=1 к DSP(те работа через порты, а не память).
В стандартных драйверах этот параметр не задействован и должен быть
всегда равен 0. 
</P>

<br clear=all style='page-break-before:always'>
<H4>outbyte</H4>

<P>Вывод байта в I/O порт. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG outbyte ( ULONG offset,
	PUCHAR data, ULONG len=1, ULONG key=0); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
	<B>function outbyte (offset:ULONG; var data:UCHAR; len:ULONG;
	key:ULONG ):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG offset </B>- смещение порта относительно базового
	адреса; <BR><B>PUCHAR data </B>- массив данных; <BR><B>ULONG len </B>-
	размер массива в байтах; <BR><B>ULONG key </B>- номер региона (
	фактически выбирает базовый адрес из списка возможных ); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 </FONT>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>В данной реализации нет проверки выхода смещения за разрешенную
границу. Про key. У некоторых плат есть несколько регионов портов
ввода/вывода. Для переключения между ними и служит этот параметр.
Например, при key=0 для L7XX будет осуществляться доступ к служебным
регистрам PLX, а при key=1 к DSP(те работа через порты, а не память).
В стандартных драйверах этот параметр не задействован и должен быть
всегда равен 0. 
</P>

<br clear=all style='page-break-before:always'>
<H4>outword</H4>

<P>Вывод слова в I/O порт. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG outword ( ULONG offset,
	PUSHORT data, ULONG len=1, ULONG key=0); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
	<B>function outword (offset:ULONG; var data:USHORT; len:ULONG;
	key:ULONG ):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG offset </B>- смещение порта относительно базового
	адреса; <BR><B>PUSHORT data </B>- массив данных; <BR><B>ULONG len </B>-
	размер массива в байтах; <BR><B>ULONG key </B>- номер региона (
	фактически выбирает базовый адрес из списка возможных ); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 </FONT>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>В данной реализации нет проверки выхода смещения за разрешенную
границу. Про key. У некоторых плат есть несколько регионов портов
ввода/вывода. Для переключения между ними и служит этот параметр.
Например, при key=0 для L7XX будет осуществляться доступ к служебным
регистрам PLX, а при key=1 к DSP(те работа через порты, а не память).
В стандартных драйверах этот параметр не задействован и должен быть
всегда равен 0. 
</P>

<br clear=all style='page-break-before:always'>
<H4>outdword</H4>

<P>Вывод двойного слова в I/O порт. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG outdword ( ULONG offset,
	PULONG data, ULONG len=1, ULONG key=0); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
	<B>function outdword (offset:ULONG; var data:ULONG; len:ULONG;
	key:ULONG ):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG offset </B>- смещение порта относительно базового
	адреса; <BR><B>PULONG data </B>- массив данных; <BR><B>ULONG len </B>-
	размер массива в байтах; <BR><B>ULONG key </B>- номер региона (
	фактически выбирает базовый адрес из списка возможных ); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L1250 L1221 L305 L264 L1450 </FONT>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>В данной реализации нет проверки выхода смещения за разрешенную
границу. Про key. У некоторых плат есть несколько регионов портов
ввода/вывода. Для переключения между ними и служит этот параметр.
Например, при key=0 для L7XX будет осуществляться доступ к служебным
регистрам PLX, а при key=1 к DSP(те работа через порты, а не память).
В стандартных драйверах этот параметр не задействован и должен быть
всегда равен 0. 
</P>

<br clear=all style='page-break-before:always'>
<H4>inmbyte</H4>

<P>Ввод байта из памяти. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG inmbyte ( ULONG offset,
	PUCHAR data, ULONG len=1, ULONG key=0); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
	<B>function inmbyte (offset:ULONG; var data:UCHAR; len:ULONG;
	key:ULONG ):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG offset </B>- смещение порта относительно базового
	адреса; <BR><B>PUCHAR data </B>- массив, в который будут занесены
	прочитанные данные; <BR><B>ULONG len </B>- размер массива в байтах;
	<BR><B>ULONG key </B>- номер региона ( фактически выбирает базовый
	адрес из списка возможных ); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; <BR><B>PUCHAR data </B>- прочитанные данные; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L791</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>В данной реализации нет проверки выхода смещения за разрешенную
границу. Про key. У некоторых плат есть несколько регионов портов
ввода/вывода. Для переключения между ними и служит этот параметр.
Например, при key=0 для L7XX будет осуществляться доступ к служебным
регистрам PLX, а при key=1 к DSP(те работа через порты, а не память).
В стандартных драйверах этот параметр не задействован и должен быть
всегда равен 0. 
</P>

<br clear=all style='page-break-before:always'>
<H4>imword</H4>

<P>Ввод слова из памяти. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG inmword ( ULONG offset,
	PUSHORT data, ULONG len=1, ULONG key=0); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
	<B>function inmword (offset:ULONG; var data:USHORT; len:ULONG;
	key:ULONG ):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG offset </B>- смещение порта относительно базового
	адреса; <BR><B>PUSHORT data </B>- массив, в который будут занесены
	прочитанные данные; <BR><B>ULONG len </B>- размер массива в байтах;
	<BR><B>ULONG key </B>- номер региона ( фактически выбирает базовый
	адрес из списка возможных ); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; <BR><B>PUSHORT data </B>- прочитанные данные; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L791</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>В данной реализации нет проверки выхода смещения за разрешенную
границу. Про key. У некоторых плат есть несколько регионов портов
ввода/вывода. Для переключения между ними и служит этот параметр.
Например, при key=0 для L7XX будет осуществляться доступ к служебным
регистрам PLX, а при key=1 к DSP(те работа через порты, а не память).
В стандартных драйверах этот параметр не задействован и должен быть
всегда равен 0. 
</P>

<br clear=all style='page-break-before:always'>
<H4>inmdword</H4>

<P>Ввод двойного слова из памяти. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG inmdword ( ULONG offset,
	PULONG data, ULONG len=1, ULONG key=0); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
	<B>function inmdword (offset:ULONG; var data:ULONG; len:ULONG;
	key:ULONG ):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG offset </B>- смещение порта относительно базового
	адреса; <BR><B>PULONG data </B>- массив, в который будут занесены
	прочитанные данные; <BR><B>ULONG len </B>- размер массива в байтах;
	<BR><B>ULONG key </B>- номер региона ( фактически выбирает базовый
	адрес из списка возможных ); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; <BR><B>PULONG data </B>- прочитанные данные; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L791</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>В данной реализации нет проверки выхода смещения за разрешенную
границу. Про key. У некоторых плат есть несколько регионов портов
ввода/вывода. Для переключения между ними и служит этот параметр.
Например, при key=0 для L7XX будет осуществляться доступ к служебным
регистрам PLX, а при key=1 к DSP(те работа через порты, а не память).
В стандартных драйверах этот параметр не задействован и должен быть
всегда равен 0. 
</P>

<br clear=all style='page-break-before:always'>
<H4>outmbyte</H4>

<P>Вывод байта в память. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG outmbyte ( ULONG offset,
	PUCHAR data, ULONG len=1, ULONG key=0); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
	<B>function outmbyte (offset:ULONG; var data:UCHAR; len:ULONG;
	key:ULONG ):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG offset </B>- смещение порта относительно базового
	адреса; <BR><B>PUCHAR data </B>- массив данных; <BR><B>ULONG len </B>-
	размер массива в байтах; <BR><B>ULONG key </B>- номер региона (
	фактически выбирает базовый адрес из списка возможных ); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L791</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>В данной реализации нет проверки выхода смещения за разрешенную
границу. Про key. У некоторых плат есть несколько регионов портов
ввода/вывода. Для переключения между ними и служит этот параметр.
Например, при key=0 для L7XX будет осуществляться доступ к служебным
регистрам PLX, а при key=1 к DSP(те работа через порты, а не память).
В стандартных драйверах этот параметр не задействован и должен быть
всегда равен 0. 
</P>

<br clear=all style='page-break-before:always'>
<H4>outmword</H4>

<P>Вывод слова в память. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG outmword ( ULONG offset,
	PUSHORT data, ULONG len=1, ULONG key=0); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
	<B>function outmword (offset:ULONG; var data:USHORT; len:ULONG;
	key:ULONG ):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG offset </B>- смещение порта относительно базового
	адреса; <BR><B>PUSHORT data </B>- массив данных; <BR><B>ULONG len </B>-
	размер массива в байтах; <BR><B>ULONG key </B>- номер региона (
	фактически выбирает базовый адрес из списка возможных ); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; <BR>- 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L791</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>В данной реализации нет проверки выхода смещения за разрешенную
границу. Про key. У некоторых плат есть несколько регионов портов
ввода/вывода. Для переключения между ними и служит этот параметр.
Например, при key=0 для L7XX будет осуществляться доступ к служебным
регистрам PLX, а при key=1 к DSP(те работа через порты, а не память).
В стандартных драйверах этот параметр не задействован и должен быть
всегда равен 0. 
</P>

<br clear=all style='page-break-before:always'>
<H4>outmdword</H4>

<P>Вывод двойного слова в память. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> <B>ULONG outmdword ( ULONG
	offset, PULONG data, ULONG len=1, ULONG key=0); </B><BR><FONT COLOR="#ff0000">Pascal:</FONT>
	<B>function outmdword (offset:ULONG; var data:ULONG; len:ULONG;
	key:ULONG ):ULONG; </B>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG offset </B>- смещение порта относительно базового
	адреса; <BR><B>PULONG data </B>- массив данных; <BR><B>ULONG len </B>-
	размер массива в байтах; <BR><B>ULONG key </B>- номер региона (
	фактически выбирает базовый адрес из списка возможных ); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Возвращает:</FONT></P>
<UL>
	<P><B>L_SUCCESS </B>- в случае успеха; <BR><B>L_ERROR </B>- в случае
	ошибки; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Реализована:</FONT></P>
<UL>
	<P><FONT COLOR="#008080">L7XX L791</FONT></P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>В данной реализации нет проверки выхода смещения за разрешенную
границу. Про key. У некоторых плат есть несколько регионов портов
ввода/вывода. Для переключения между ними и служит этот параметр.
Например, при key=0 для L7XX будет осуществляться доступ к служебным
регистрам PLX, а при key=1 к DSP(те работа через порты, а не память).
В стандартных драйверах этот параметр не задействован и должен быть
всегда равен 0. 
</P>

<br clear=all style='page-break-before:always'>
<H3>Типы данных</H3>
<H4>ADC_PAR</H4>

<P>Это обобщенная структура для удобства работы со структурами задачи
параметров сбора данных разных плат. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT></P>
	<PRE><B>typedef union _ADC_PARAM_U_ :</B>
<B>{</B></PRE>
	<UL>
		<PRE><B>ADC_PAR_0 t1;</B>
<B>ADC_PAR_1 t2;</B></PRE>
	</UL>
	<PRE><B>} ADC_PAR, *PADC_PAR;</B>
</PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P><BR><BR>
</P>

<br clear=all style='page-break-before:always'>
<H4>ADC_PAR_0</H4>

<P>Структура служит для передачи параметров сбора данных в плату.
Заполняется пользователем и передается в драйвер где и хранится. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT></P>
	<PRE><B>typedef struct _ADC_PARAM_U_0 : public DAQ_PAR</B>
<B>{</B>
<B>// ULONG s_Type;</B>
<B>// ULONG FIFO;</B>
<B>// ULONG IrqStep;</B>
<B>// ULONG Pages;</B>

   <B>ULONG AutoInit;</B>
   <B>double dRate;</B>
   <B>double dKadr;</B>
   <B>double dScale;</B>
<B>*  ULONG Rate;</B>
<B>*  ULONG Kadr;</B>
<B>*  ULONG Scale;</B>
<B>*  ULONG FPDelay</B>
   <B>ULONG SynchroType;</B>
   <B>ULONG SynchroSensitivity;</B>
   <B>ULONG SynchroMode;</B>
   <B>ULONG AdChannel;</B>
   <B>ULONG AdPorog;</B>
   <B>ULONG NCh;</B>
   <B>ULONG Chn[128];</B>
   <B>ULONG IrqEna;</B>
   <B>ULONG AdcEna;</B>
<B>} ADC_PAR_0, *PADC_PAR_0;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG s_Type </B>- тип структуры (должен быть L_ADC_PARAM);
	<BR><B>ULONG AutoInit </B>- флаг указывающий на тип сбора данных 0 -
	однократный 1 - циклический; <BR><B>double dRate </B>- частота
	опроса каналов в кадре (кГц); <BR><B>double dKadr </B>- интервал
	между кадрами (мс); <BR><B>double dScale </B>- масштаб работы
	таймера для 1250 или делителя для 1221; <BR><B>ULONG Rate </B>-
	частота опроса каналов в кадре (в кодах для процессора, вычисляется
	библиотекой); <BR><B>ULONG Kadr </B>- интервал между кадрами (в
	кодах для процессора, вычисляется библиотекой); <BR><B>ULONG Scale </B>-
	масштаб работы таймера для 1250 или делителя для 1221 (в кодах для
	процессора, вычисляется библиотекой); <BR><B>ULONG FPDelay </B>-
	служебная величина задержки выдачи первого отсчета (вычисляется
	библиотекой); <BR><B>ULONG SynchroType </B>- тип синхронизации;
	<BR><B>ULONG SynchroSensitivity </B>- вид синхронизации; <BR><B>ULONG
	SynchroMode </B>- режим синхронизации; <BR><B>ULONG AdChannel </B>-
	канал, по которому выполняется синхронизация; <BR><B>ULONG AdPorog </B>-
	уровень синхронизации; <BR><B>ULONG NCh </B>- количество
	опрашиваемых каналов ; <BR><B>ULONG Chn[128] </B>- массив с номерами
	каналов и усилением на них; описывает порядок опроса каналов; <BR><B>ULONG
	FIFO </B>- размер половины аппаратного буфера FIFO на плате; <BR><B>ULONG
	IrqStep </B>- шаг генерации прерываний; <BR><B>ULONG Pages </B>-
	размер кольцевого буфера в шагах прерываний; <BR><B>ULONG IrqEna </B>-
	разрешение генерации прерывания от платы (1/0); <BR><B>ULONG AdcEna
	</B>- разрешение работы АЦП (1/0); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Структура ADC_PAR используется совместно с вызовом
FillDAQparameters для настройки параметров ввода данных с платы АЦП.
Поля отмеченные комментарием (//) наследуются из структуры DAQ_PAR.
Пользователь должен заполнять все поля кроме тех, которые помечены
(*). Особенности трактовки полей этой структуры для различных плат: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm; font-style: normal"><B>L-761/780/783</B></P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>s_Type</B> - должен быть
		L_ADC_PARAM;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>AutoInit</B> - (<B>0</B> -
		однократное заполнение большого буфера и если установлено событие в
		функции SetLDeviceEvent, то произойдет генерация события)/( <B>1</B>
		циклическое заполнение буфера);</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>dRate</B> - частота опроса
		каналов в кадре в килогерцах;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>dKadr</B> - интервал между
		кадрами в миллисекундах, фактически определяет скорость сбора
		данных;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>SynchroType</B></P>
		<UL>
			<LI><P STYLE="margin-bottom: 0cm"><B>0</B> - цифровая
			синхронизация старта, остальные параметры синхронизации не
			используются;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>1</B> &ndash; по-кадровая
			синхронизация, остальные параметры синхронизации не используются;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>2</B> &ndash; аналоговая
			синхронизация старта по выбранному каналу АЦП;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>3</B> &ndash; нет
			синхронизации;</P>
		</UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>SynchroSensitivity</B></P>
		<UL>
			<LI><P STYLE="margin-bottom: 0cm"><B>0</B> &ndash; аналоговая
			синхронизация по уровню;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>1</B> &ndash; аналоговая
			синхронизация по переходу;</P>
		</UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>SynchroMode</B></P>
		<UL>
			<LI><P STYLE="margin-bottom: 0cm"><B>0</B> &ndash; по уровню
			&laquo;выше&raquo; или переходу &laquo;снизу-вверх&raquo;;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>1</B> - по уровню &laquo;ниже&raquo;
			или переходу &laquo;сверху-вниз&raquo;;</P>
		</UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>AdChannel</B> - канала,
		выбранный для аналоговой синхронизации;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>AdPorog</B> - пороговое
		значение для аналоговой синхронизации в коде АЦП;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>Nch</B> &ndash; количество
		опрашиваемых в кадре каналов;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>Chn</B> &ndash; массив с
		логическими номерами каналов, слово вида 00000000 XXXXXXXX;</P>
		<TABLE WIDTH=324 BORDER=1 CELLPADDING=4 CELLSPACING=3>
			<COL WIDTH=83>
			<COL WIDTH=100>
			<COL WIDTH=103>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>№ бита</P>
				</TD>
				<TD WIDTH=100>
					<P>Обозначение</P>
				</TD>
				<TD WIDTH=103>
					<P>Назначение</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>0</P>
				</TD>
				<TD WIDTH=100>
					<P>MA0</P>
				</TD>
				<TD WIDTH=103>
					<P>0 бит номера</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>1</P>
				</TD>
				<TD WIDTH=100>
					<P>MA1</P>
				</TD>
				<TD WIDTH=103>
					<P>1 бит номера</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>2</P>
				</TD>
				<TD WIDTH=100>
					<P>MA2</P>
				</TD>
				<TD WIDTH=103>
					<P>2 бит номера</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>3</P>
				</TD>
				<TD WIDTH=100>
					<P>MA3</P>
				</TD>
				<TD WIDTH=103>
					<P>3 бит номера</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>4</P>
				</TD>
				<TD WIDTH=100>
					<P>MA4</P>
				</TD>
				<TD WIDTH=103>
					<P>&laquo;0&raquo;/ 4 бит</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>5</P>
				</TD>
				<TD WIDTH=100>
					<P>MA5</P>
				</TD>
				<TD WIDTH=103>
					<P>16 диф/32 общ</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>6</P>
				</TD>
				<TD WIDTH=100>
					<P>GS0</P>
				</TD>
				<TD WIDTH=103>
					<P>0 бит усил.</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>7</P>
				</TD>
				<TD WIDTH=100>
					<P>GS1</P>
				</TD>
				<TD WIDTH=103>
					<P>1 бит усил.</P>
				</TD>
			</TR>
		</TABLE>
		<UL>
			<P STYLE="margin-bottom: 0cm">MA5=MA4=0, MA3-MA0 &ndash; номер
			диф. канала.</P>
			<P STYLE="margin-bottom: 0cm">MA5=0 MA4=1 &ndash; калибровка нуля.</P>
			<P STYLE="margin-bottom: 0cm">MA5=1 MA4-MA0 &ndash; номер входа с
			общей землей.</P>
			<P STYLE="margin-bottom: 0cm">GS0 GS1= {00, 01, 10, 11} - усиление
			{1, 4, 16, 64} для 780/761 и {1, 2, 4, 8} для 783.</P>
		</UL>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>L-1450</B></P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>s_Type</B> - должен быть
		L_ADC_PARAM;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>AutoInit</B> - (<B>0</B> -
		однократное заполнение большого буфера и если установлено событие в
		функции SetLDeviceEvent, то произойдет генерация события)/( <B>1</B>
		циклическое заполнение буфера);</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>dRate</B> - частота опроса
		каналов в кадре в килогерцах;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>dKadr</B> - интервал между
		кадрами в миллисекундах, фактически определяет скорость сбора
		данных;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>SynchroType</B></P>
		<UL>
			<LI><P STYLE="margin-bottom: 0cm"><B>0</B> - цифровая
			синхронизация старта, остальные параметры синхронизации не
			используются;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>1</B> &ndash; по-кадровая
			синхронизация, остальные параметры синхронизации не используются;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>2</B> &ndash; аналоговая
			синхронизация старта по выбранному каналу АЦП;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>3</B> &ndash; нет
			синхронизации;</P>
		</UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>SynchroSensitivity</B></P>
		<UL>
			<LI><P STYLE="margin-bottom: 0cm"><B>0</B> &ndash; аналоговая
			синхронизация по уровню;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>1</B> &ndash; аналоговая
			синхронизация по переходу;</P>
		</UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>SynchroMode</B></P>
		<UL>
			<LI><P STYLE="margin-bottom: 0cm"><B>0</B> &ndash; по уровню
			&laquo;выше&raquo; или переходу &laquo;снизу-вверх&raquo;;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>1</B> - по уровню &laquo;ниже&raquo;
			или переходу &laquo;сверху-вниз&raquo;;</P>
		</UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>AdChannel</B> - канала,
		выбранный для аналоговой синхронизации;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>AdPorog</B> - пороговое
		значение для аналоговой синхронизации в коде АЦП;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>Nch</B> &ndash; количество
		опрашиваемых в кадре каналов;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>Chn</B> &ndash; массив с
		логическими номерами каналов, слово вида 00000000 XXXXXXXX;</P>
		<TABLE WIDTH=324 BORDER=1 CELLPADDING=4 CELLSPACING=3>
			<COL WIDTH=83>
			<COL WIDTH=100>
			<COL WIDTH=103>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>№ бита</P>
				</TD>
				<TD WIDTH=100>
					<P>Обозначение</P>
				</TD>
				<TD WIDTH=103>
					<P>Назначение</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>0</P>
				</TD>
				<TD WIDTH=100>
					<P>MA0</P>
				</TD>
				<TD WIDTH=103>
					<P>0 бит номера</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>1</P>
				</TD>
				<TD WIDTH=100>
					<P>MA1</P>
				</TD>
				<TD WIDTH=103>
					<P>1 бит номера</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>2</P>
				</TD>
				<TD WIDTH=100>
					<P>MA2</P>
				</TD>
				<TD WIDTH=103>
					<P>2 бит номера</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>3</P>
				</TD>
				<TD WIDTH=100>
					<P>MA3</P>
				</TD>
				<TD WIDTH=103>
					<P>3 бит номера</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>4</P>
				</TD>
				<TD WIDTH=100>
					<P>MA4</P>
				</TD>
				<TD WIDTH=103>
					<P>&laquo;0&raquo;/ 4 бит</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>5</P>
				</TD>
				<TD WIDTH=100>
					<P>MA5</P>
				</TD>
				<TD WIDTH=103>
					<P>16 диф/32 общ</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>6</P>
				</TD>
				<TD WIDTH=100>
					<P>GS0</P>
				</TD>
				<TD WIDTH=103>
					<P>0 бит усил.</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>7</P>
				</TD>
				<TD WIDTH=100>
					<P>GS1</P>
				</TD>
				<TD WIDTH=103>
					<P>1 бит усил.</P>
				</TD>
			</TR>
		</TABLE>
		<UL>
			<P STYLE="margin-bottom: 0cm">MA5=MA4=0, MA3-MA0 &ndash; номер
			диф. канала.</P>
			<P STYLE="margin-bottom: 0cm">MA5=0 MA4=1 &ndash; калибровка нуля.</P>
			<P STYLE="margin-bottom: 0cm">MA5=1 MA4-MA0 &ndash; номер входа с
			общей землей.</P>
			<P STYLE="margin-bottom: 0cm; font-weight: medium">GS0 GS1= {00,
			01, 10, 11} - усиление {1, 4, 16, 64}.</P>
		</UL>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>E14-440/E14-140/E154</B></P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>s_Type</B> - должен быть
		L_ADC_PARAM;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>AutoInit</B> - (<B>0</B> -
		однократное заполнение большого буфера и если установлено событие в
		функции SetLDeviceEvent, то произойдет генерация события)/( <B>1</B>
		циклическое заполнение буфера);</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>dRate</B> - частота опроса
		каналов в кадре в килогерцах;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>dKadr</B> - интервал между
		кадрами в миллисекундах, фактически определяет скорость сбора
		данных;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>SynchroType</B></P>
		<UL>
			<LI><P STYLE="margin-bottom: 0cm"><B>0 </B>&ndash; <SPAN STYLE="font-weight: medium">нет
			синхронизации;</SPAN></P>
			<LI><P STYLE="margin-bottom: 0cm"><B>1</B> - цифровая
			синхронизация старта, остальные параметры синхронизации не
			используются;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>2</B> &ndash; по-кадровая
			синхронизация, остальные параметры синхронизации не используются;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>3</B> &ndash; аналоговая
			синхронизация старта по выбранному каналу АЦП;</P>
			<P STYLE="margin-bottom: 0cm">для <B>E140</B> сюда еще можно
			добавить биты 6 и 7, 6 бит включает внешний clock, 7 бит разрешает
			трансляцию clock на внешний разъем</P>
		</UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>SynchroSensitivity</B></P>
		<UL>
			<LI><P STYLE="margin-bottom: 0cm"><B>0</B> &ndash; аналоговая
			синхронизация по уровню;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>1</B> &ndash; аналоговая
			синхронизация по переходу;</P>
		</UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>SynchroMode</B></P>
		<UL>
			<LI><P STYLE="margin-bottom: 0cm"><B>0</B> &ndash; по уровню
			&laquo;выше&raquo; или переходу &laquo;снизу-вверх&raquo;;</P>
			<LI><P STYLE="margin-bottom: 0cm"><B>1</B> - по уровню &laquo;ниже&raquo;
			или переходу &laquo;сверху-вниз&raquo;;</P>
		</UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>AdChannel</B> - канала,
		выбранный для аналоговой синхронизации;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>AdPorog</B> - пороговое
		значение для аналоговой синхронизации в коде АЦП;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>Nch</B> &ndash; количество
		опрашиваемых в кадре каналов;(для E154 макс. 16)</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>Chn</B> &ndash; массив с
		логическими номерами каналов, слово вида 00000000 XXXXXXXX;</P>
		<TABLE WIDTH=324 BORDER=1 CELLPADDING=4 CELLSPACING=3>
			<COL WIDTH=83>
			<COL WIDTH=100>
			<COL WIDTH=103>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>№ бита</P>
				</TD>
				<TD WIDTH=100>
					<P>Обозначение</P>
				</TD>
				<TD WIDTH=103>
					<P>Назначение</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>0</P>
				</TD>
				<TD WIDTH=100>
					<P>MA0</P>
				</TD>
				<TD WIDTH=103>
					<P>0 бит номера</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>1</P>
				</TD>
				<TD WIDTH=100>
					<P>MA1</P>
				</TD>
				<TD WIDTH=103>
					<P>1 бит номера</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>2</P>
				</TD>
				<TD WIDTH=100>
					<P>MA2</P>
				</TD>
				<TD WIDTH=103>
					<P>2 бит номера</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>3</P>
				</TD>
				<TD WIDTH=100>
					<P>MA3</P>
				</TD>
				<TD WIDTH=103>
					<P>3 бит номера</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>4</P>
				</TD>
				<TD WIDTH=100>
					<P>MA4</P>
				</TD>
				<TD WIDTH=103>
					<P>&laquo;0&raquo;/ 4 бит</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>5</P>
				</TD>
				<TD WIDTH=100>
					<P>MA5</P>
				</TD>
				<TD WIDTH=103>
					<P>16 диф/32 общ</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>6</P>
				</TD>
				<TD WIDTH=100>
					<P>GS0</P>
				</TD>
				<TD WIDTH=103>
					<P>0 бит усил.</P>
				</TD>
			</TR>
			<TR VALIGN=TOP>
				<TD WIDTH=83>
					<P>7</P>
				</TD>
				<TD WIDTH=100>
					<P>GS1</P>
				</TD>
				<TD WIDTH=103>
					<P>1 бит усил.</P>
				</TD>
			</TR>
		</TABLE>
		<UL>
			<P STYLE="margin-bottom: 0cm">MA5=MA4=0, MA3-MA0 &ndash; номер
			диф. канала.</P>
			<P STYLE="margin-bottom: 0cm">MA5=0 MA4=1 &ndash; калибровка нуля.</P>
			<P STYLE="margin-bottom: 0cm">MA5=1 MA4-MA0 &ndash; номер входа с
			общей землей.</P>
			<P STYLE="margin-bottom: 0cm; font-weight: medium">GS0 GS1= {00,
			01, 10, 11} - усиление {1, 4, 16, 64} .</P>
		</UL>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>L-1250/51/L-1450C/L-305/L-264: </B>
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>NCh</B> - количество каналов
		(максимум 32); 
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>IrqStep</B> - должен быть
		равен FIFO т.к. плата может работать только по половинкам фифо
		буфера; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>SynchroType</B> - тип
		синхронизации (SMode по описанию DOS); 
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>SynchroMode</B> - режим
		синхронизации (TtlMask по описанию DOS); 
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>L-1221: </B>
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>dRate</B> - частота опроса на
		каждом канале. 
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>NCh</B> - битовая маска
		активных каналов (10101010 for example); 
		</P>
		<LI><P><B>Chn[32]</B> - первые 8 членов задают усиление на
		соответствующих каналах; 
		</P>
	</UL>
</UL>

<br clear=all style='page-break-before:always'>
<H4>ADC_PAR_1</H4>

<P>Структура служит для передачи параметров сбора данных в плату.
Заполняется пользователем и передается в драйвер где и хранится. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT></P>
	<PRE><B>typedef struct _ADC_PARAM_U_1 : public DAQ_PAR</B>
<B>{</B>
<B>// ULONG s_Type;</B>
<B>// ULONG FIFO;</B>
<B>// ULONG IrqStep;</B>
<B>// ULONG Pages;</B>

   <B>ULONG AutoInit;</B>
   <B>double dRate;</B>
   <B>double dKadr;</B>
   <B>ULONG Reserved1;</B>
   <B>ULONG DM_Ena;</B>
<B>*  ULONG Rate;</B>
<B>*  ULONG Kadr;</B>
   <B>ULONG StartCnt;</B>
   <B>ULONG StopCnt;</B>
   <B>ULONG SynchroType;</B>
   <B>ULONG SynchroMode;</B>
   <B>ULONG AdPorog;</B>
   <B>ULONG SynchroSrc;</B>
   <B>ULONG AdcIMask;</B>
   <B>ULONG NCh;</B>
   <B>ULONG Chn[128];</B>
   <B>ULONG IrqEna;</B>
   <B>ULONG AdcEna;</B>
<B>} ADC_PAR_1, *PADC_PAR_1;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG s_Type </B>- тип структуры (должен быть L_ADC_PARAM);
	<BR><B>ULONG AutoInit </B>- флаг указывающий на тип сбора данных 0 -
	однократный 1 - циклический; <BR><B>double dRate </B>- частота
	опроса каналов в кадре (кГц); <BR><B>double dKadr </B>- интервал
	между кадрами (мс); <BR><B>ULONG Reserved1</B> &ndash;
	зарезервировано;</P>
	<P><B>ULONG DM_Ena</B> - разрешение/запрещение маркировки данных
	<B>ULONG Rate </B>- частота опроса каналов в кадре (в кодах для
	цифрового автомата); <BR><B>ULONG Kadr </B>- интервал между кадрами
	(в кодах для цифрового автомата); <BR><B>ULONG StartCnt &ndash;</B>
	задержка старта в кадрах; <BR><B>ULONG StopCnt &mdash;</B> сколько
	кадров собирать после старта; <BR><B>ULONG SynchroType </B>- тип
	синхронизации; <BR><B>ULONG SynchroMode &ndash;</B> режим
	синхронизации и номер канала; <BR><B>ULONG AdPorog &mdash;</B> порог
	синхронизации; <BR><B>ULONG SynchroSrc &ndash;</B> источник внешней
	синхронизации; <BR><B>ULONG AdcIMask &ndash;</B> задает режим ввода
	по каналам у модуля E2010; <BR><B>ULONG NCh </B>- количество
	опрашиваемых каналов ; <BR><B>ULONG Chn[128] </B>- массив с номерами
	каналов и усилением на них; описывает порядок опроса каналов; <BR><B>ULONG
	FIFO </B>- размер половины аппаратного буфера FIFO на плате; <BR><B>ULONG
	IrqStep</B>; <BR><B>ULONG Pages &ndash;</B> произведение этих двух
	параметров IrqStep*Pages задает количество отсчетов которое соберет
	плата при однократном сборе, но не больше чем 128К отсчетов. При
	циклическом сборе они игнорируются &ndash; буфер всегда 128К.<BR><B>ULONG
	IrqEna </B>- разрешение генерации прерывания от платы (mask/0), при
	этом mask - это младшие 16 бит в слове разрешающем прерывания от
	платы (блок АЦП); <BR><B>ULONG AdcEna </B>- разрешение работы АЦП
	(1/0); 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Структура ADC_PAR _1 используется совместно с вызовом
FillDAQparameters для настройки параметров ввода данных с платы АЦП.
Поля отмеченные комментарием (//) наследуются из структуры DAQ_PAR.
Пользователь должен заполнять все поля кроме тех, которые помечены
(*). Особенности трактовки полей этой структуры для различных плат: 
</P>
<UL>
	<LI><B>L-791</B> 
	<UL>
		<LI><B>s_Type </B>- тип структуры (должен быть L_ADC_PARAM);<LI>
		<B>AutoInit </B>- флаг указывающий на тип сбора данных 0 -
		однократный 1 &ndash; циклический;<LI>
		<B>dRate </B>- частота опроса каналов в кадре (кГц);<LI>
		<B>dKadr </B>- интервал между кадрами (мс);<LI>
		<B>Rate </B>- частота опроса каналов в кадре (в кодах для цифрового
		автомата);<LI>
		<B>Kadr </B>- интервал между кадрами (в кодах для цифрового
		автомата);<LI>
		<B>SynchroType </B>- тип синхронизации;<LI>
		<B>SynchroSrc &ndash;</B> источник внешней синхронизации;<LI>
		<B>NCh </B>- количество опрашиваемых каналов ;<LI>
		<B>Chn[128] </B>- массив с номерами каналов и усилением на них;
		описывает порядок опроса каналов;<LI>
		<B>FIFO </B>- размер половины аппаратного буфера FIFO на плате,
		возможные значения 1,2,4,8,16,32,64,128 отсчетов. При этом при
		первых трех возможных значениях передача BusMaster идет одиночными
		значениями, а при большем пакетная передача. Если установить больше
		128, то она сама сбросит до 128.<LI>
		<B>IrqStep</B>;<LI>
		<B>Pages &ndash;</B> произведение этих двух параметров
		IrqStep*Pages задает количество отсчетов которое соберет плата при
		однократном сборе, но не больше чем 128К отсчетов. При циклическом
		сборе они игнорируются &ndash; буфер всегда 128К. При IrqEna=1
		сгенерит еще прерывание.<LI>
		<B>IrqEna </B>- разрешение генерации прерывания от платы (mask/0),
		при этом mask - это младшие 16 бит в слове разрешающем прерывания
		от платы (блок АЦП) см. описание платы;<LI>
		<B>AdcEna </B>- разрешение работы АЦП (1/0); 
	</UL>
	<LI><B>E20-10</B> 
	<UL>
		<LI><B>s_Type </B>- тип структуры (должен быть L_ADC_PARAM);<LI>
		<B>AutoInit </B>- флаг указывающий на тип сбора данных 0 -
		однократный 1 &ndash; циклический;<LI>
		<B>dRate </B>- частота опроса каналов в кадре (кГц);<LI>
		<B>dKadr </B>- интервал между кадрами (мс);<LI>
		<B>Rate </B>- частота опроса каналов в кадре (в кодах для цифрового
		автомата);<LI>
		<B>Kadr </B>- интервал между кадрами (в кодах для цифрового
		автомата);<LI><P>
		<B>SynchroType </B>- тип синхронизации;</P>
		<P>задается константами, определенными в файле e2010cmd.h 
		<UL>
			<LI><B>INT_START_TRANS 0x01</B> &ndash; внутренний старт с
			разрешением трансляции сигнала на разъем;<LI>
			<B>INT_START 0x81</B> &ndash; просто внутренний старт;<LI>
			<B>EXT_START_UP 0x84</B> &ndash; внешний импульс старта по
			переднему фронту;<LI>
			<B>EXT_START_DOWN 0x94</B> &ndash; внешний импульс старта по
			заднему фронту;<LI>
			<B>EXT_START_DOWN_REVB  0x8C</B> &ndash; внешний импульс старта по
			заднему фронту для ревизии B;</UL>
		<LI><B>SynchroSrc &ndash;</B> источник тактовыйх импульсов для АЦП;
		
		<UL>
			<LI><B>INT_CLK_TRANS 0x00</B> &ndash; внутренний источник с
			трансляцией;<LI>
			<B>INT_CLK 0x40</B> &ndash; просто внутренний источник;<LI>
			<B>EXT_CLK_UP 0x42</B> &ndash; внешний источник, по переднему
			фронту;<LI>
			<B>EXT_CLK_DOWN 0x62</B> &ndash; внешний источник, по заднему
			фронту;</UL>
		<LI><P><B>AdcIMask &ndash;</B> задает режим ввода по каналам у
		модуля E2010, сигнал или земля + входной диапазон;</P>
		<P>задается константами, определенными в файле e2010cmd.h через (+)</P>
		<P>для 0 канала 
		<UL>
			<LI><B>V30_0 0x0000</B> &ndash; диапазон 3 В;<LI>
			<B>V10_0 0x0008</B> &ndash; 1 В;<LI>
			<B>V03_0 0x0010</B> &ndash; 0.3 В;<LI>
			<B>GND_0 0x0000</B> &ndash; вход заземлен;<LI><P>
			<B>SIG_0 0x0400</B> &ndash; вход подключен к сигналу;</P>
			<P>для остальных каналов аналогично с префиксами <B>_1 _2 _3</B>;</UL>
		<LI><B>NCh </B>- количество опрашиваемых каналов ;<LI>
		<B>Chn[128] </B>- массив с номерами каналов, описывает порядок
		опроса каналов;<LI>
		<B>FIFO </B>-фактически не используется.<LI><P>
		<B>IrqStep</B> &ndash; размер запроса циклической посылки данных к
		USB, не более 1М отсчтетов;</P>
	</UL>
	<LI><B>Расширенные параметры синхронизации для E20-10B</B>
	<UL><LI>
		<B>DM_Ena &mdash; </B>вкл/выкл маркирования начала блоков вводимых
		данных (удобно, например, при аналоговой синхронизации ввода по
		уровню);<LI>
		<B>StartCnt</B> - задержка старта сбора данных в кадрах отсчётов
		АЦП;<LI>
		<B>StopCnt</B> - останов сбора данных после задаваемого здесь
		кол-ва собранных кадров отсчётов АЦП;<LI>
		<B>SynchroMode</B> &mdash; режим аналоговой синхронизации и номер
		канал;
		<UL><LI>
			<B>A_SYNC_OFF 0x0000</B> &mdash; нет аналоговой синхронизации;<LI>
			<B>A_SYNC_UP_EDGE 0x0080</B> &mdash; синхронизация по переднему
			фронту;<LI>
			<B>A_SYNC_DOWN_EDGE 0x0084</B> &mdash; синхронизация по заднему
			фронту;<LI>
			<B>A_SYNC_HL_LEVEL 0x0088</B> &mdash; синхронизация по
			положительному уровню;<LI>
			<B>A_SYNC_LH_LEVEL 0x008C</B> &mdash; синхронизация по
			отрицательно уровню;<LI>
			+ по |(или) соединить с номером канала по которому синхронизация 
			CH_0 или  CH_1 или CH_2 или CH-3.</UL>
		<LI><P><B>AdPorog</B> - порог срабатывания при аналоговой
		синхронизации;</P>
	</UL>
</UL>
<P><BR><BR>
</P>

<br clear=all style='page-break-before:always'>
<H4>DAC_PAR</H4>

<P>Это обобщенная структура для удобства работы со структурами задачи
параметров сбора данных разных плат. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT></P>
	<PRE><B>typedef union _DAC_PARAM_U_ :</B>
<B>{</B></PRE>
	<UL>
		<PRE><B>DAC_PAR_0 t1;</B>
<B>DAC_PAR_1 t2;</B></PRE>
	</UL>
	<PRE STYLE="margin-bottom: 0.5cm"><B>} DAC_PAR, *PDAC_PAR;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>

<br clear=all style='page-break-before:always'>
<H4>DAC_PAR_0</H4>

<P>Структура служит для передачи параметров вывода данных в плату.
Заполняется пользователем и передается в драйвер где хранится в
похожей структуре, но в удобном для платы представлении. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> 
	</P>
	<PRE><B>typedef struct _DAC_PARAM_U_0: public DAQ_PAR</B>
<B>{</B>
<B>// ULONG s_Type;  </B>
<B>// ULONG FIFO;</B>
<B>// ULONG IrqStep;</B>
<B>// ULONG Pages;</B>
   
   <B>ULONG AutoInit;</B>
   <B>double dRate;</B>
<B>*  ULONG Rate;</B>
   <B>ULONG IrqEna;</B>
   <B>ULONG DacEna;</B>
   <B>ULONG DacNumber;</B>
<B>} DAC_PAR_0, *PDAC_PAR_0;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG s_Type </B>-; тип структуры (должен быть L_DAC_PARAM);
	<BR><B>ULONG AutoInit </B>- флаг указывающий на тип сбора данных 0 -
	однократный 1 - циклический; (пока не используется) <BR><B>double
	dRate </B>- частота вывода данных на ЦАП (кГц); <BR><B>ULONG Rate </B>-
	частота вывода данных на ЦАП (в кодах для процессора); <BR><B>ULONG
	FIFO </B>- размер половины аппаратного буфера FIFO на плате; <BR><B>ULONG
	IrqStep </B>- шаг генерации прерываний; <BR><B>ULONG Pages </B>-
	размер кольцевого буфера в шагах прерываний; <BR><B>ULONG IrqEna </B>-
	разрешение генерации прерывания от платы (1/0); <BR><B>ULONG DacEna
	</B>- разрешение работы ЦAП (1/0); <BR><B>ULONG DacNumber </B>-
	номер канала ЦАП на который выводить данные; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Структура DAC_PAR_0 используется совместно с вызовом
FillDAQparameters для настройки параметров вывода данных с ЦАП платы.
Поля отмеченные комментарием (//) наследуются из структуры DAQ_PAR.
Пользователь должен заполнять все поля кроме тех, которые помечены
(*). Особенности трактовки полей этой структуры для различных плат: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">L-761/780/783/L-1450 - полностью
	так, как описано кроме: 
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>DacNumber</B> - не
		задействован (номер ЦАП задается в самих данных); 
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>IrqEna,Pages</B>- прерывания и
		реальный кольцевой буфер работают только в L-1450 и L780C, для
		остальных плат Pages всегда надо задавать 2; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>IrqStep</B> - должен быть
		равен FIFO; 
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm">L-1250/51/L-305/L-264: 
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>IrqEna,Pages</B> - прерывания
		и реальный кольцевой буфер работают только в L-1450 и L780C, для
		остальных плат Pages всегда надо задавать 2; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>IrqStep</B> - должен быть
		равен FIFO т.к. плата может работать только по половинкам фифо
		буфера; 
		</P>
		<LI><P><B>dRate</B> - надо ставить такой же как и для АЦП т.к. ЦАП
		на этих платах как бы синхронен с АЦП - на ввод одного кадра с АЦП
		происходит один вывод на ЦАП; 
		</P>
	</UL>
</UL>

<br clear=all style='page-break-before:always'>
<H4>DAC_PAR_1</H4>

<P>Структура служит для передачи параметров вывода данных в плату.
Заполняется пользователем и передается в драйвер где хранится в
похожей структуре, но в удобном для платы представлении. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> 
	</P>
	<PRE><B>typedef struct _DAC_PARAM_U_1: public DAQ_PAR</B>
<B>{</B>
<B>// ULONG s_Type;  </B>
<B>// ULONG FIFO;</B>
<B>// ULONG IrqStep;</B>
<B>// ULONG Pages;</B>
   
   <B>ULONG AutoInit;</B>
   <B>double dRate;</B>
<B>*  ULONG Rate;</B>
   <B>ULONG IrqEna;</B>
   <B>ULONG DacEna;</B>
   <B>ULONG Reserved1;</B>
<B>} DAC_PAR_1, *PDAC_PAR_1;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG s_Type </B>-; тип структуры (должен быть L_DAC_PARAM);
	<BR><B>ULONG AutoInit </B>- флаг указывающий на тип сбора данных 0 -
	однократный 1 - циклический; (пока не используется) <BR><B>double
	dRate </B>- частота вывода данных на ЦАП (кГц); <BR><B>ULONG Rate </B>-
	частота вывода данных на ЦАП (в кодах для процессора); <BR><B>ULONG
	FIFO </B>- размер половины аппаратного буфера FIFO на плате; <BR><B>ULONG
	IrqStep </B>- шаг генерации прерываний; <BR><B>ULONG Pages </B>-
	размер кольцевого буфера в шагах прерываний; <BR><B>ULONG IrqEna </B>-
	разрешение генерации прерывания от платы (1/0); <BR><B>ULONG DacEna
	</B>- разрешение работы ЦAП (1/0); <BR><BR><BR>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Структура DAC_PAR_1 используется совместно с вызовом
FillDAQparameters для настройки параметров вывода данных с ЦАП платы.
Поля отмеченные комментарием (//) наследуются из структуры DAQ_PAR.
Пользователь должен заполнять все поля кроме тех, которые помечены
(*). Особенности трактовки полей этой структуры для различных плат: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">L-791 - полностью так, как описано
	кроме: 
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm"><B>AutoInit</B> &ndash; не
		используется;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>IrqStep</B> &ndash; не
		используется;</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>Pages</B>- не используется,
		буфер всегда 128К отсчетов; 
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><B>FIFO,IrqStep</B> &ndash; не
		используется, буфер всегда 128К отсчетов; прерывания генерируются
		по флагам в данных ЦАП</P>
	</UL>
</UL>

<br clear=all style='page-break-before:always'>
<H4>ASYNC_PAR</H4>

<P>Структура служит для передачи в плату параметров асинхронного
ввода/вывода данных. Используется совместно IoAsync. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT></P>
	<PRE><B>typedef struct _ASYNC_PARAM_ : public DAQ_PAR</B>
<B>{</B>
<B>// USHORT s_Type;</B>
<B>// USHORT FIFO;</B>
<B>// USHORT IrqStep;</B>
<B>// USHORT Pages;</B>

   <B>double dRate;</B>
<B>*  USHORT Rate;</B>
   <B>USHORT NCh;</B>
   <B>USHORT Chn[128];</B>
   <B>USHORT Data[128];</B>
   <B>ULONG  Mode;</B>
   
<B>} ADC_PAR, *PADC_PAR;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>USHORT s_Type </B>- указывает для какой опреации ввода/вывода
	содержатся данные в структуре (L_ASYNC_ADC_CFG,
	L_ASYNC_TTL_CFG,L_ASYNC_DAC_CFG, L_ASYNC_ADC_INP, L_ASYNC_TTL_INP,
	L_ASYNC_TTL_OUT, L_ASYNC_DAC_OUT); <BR><B>USHORT Data[128] </B>-
	массив для данных; <BR><B>double dRate </B>- частота опроса каналов
	в кадре (кГц); <BR><B>USHORT Rate </B>- частота опроса каналов в
	кадре (в кодах для процессора); <BR><B>USHORT NCh </B>- количество
	опрашиваемых каналов ; <BR><B>USHORT Chn[128] </B>- массив с
	номерами каналов и усилением на них; описывает порядок опроса
	каналов; <BR><B>USHORT FIFO </B>- размер половины аппаратного буфера
	FIFO на плате; <BR><B>USHORT IrqStep </B>- шаг генерации прерываний;
	<BR><B>USHORT Pages </B>- размер кольцевого буфера в шагах
	прерываний; <BR><B>USHORT Mode </B>- задает различные режимы при
	конфигурации. 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Структура ASYNC_PAR используется совместно с вызовом IoAsync. Поля
отмеченные комментарием (//) наследуются из структуры DAQ_PAR.
Пользователь должен заполнять все поля кроме тех, которые помечены
(*). Как заполнять или что читать из этой структуры см. описание
функции IoAsync. 
</P>

<br clear=all style='page-break-before:always'>
<H4>PLATA_DESCR</H4>

<P>Структура описывает FLASH на PCI платах L-761/L-780/L-783. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> 
	</P>
	<PRE><B>typedef struct __PLATA_DESCR</B>
<B>{</B>
   <B>char SerNum[9];</B>
   <B>char BrdName[5];</B>
   <B>char Rev;</B>
   <B>char DspType[5];</B>
   <B>long Quartz;</B>
   <B>USHORT IsDacPresent;</B>
   <B>USHORT Reserv1[7];</B>
   <B>USHORT KoefADC[8];</B>
   <B>USHORT KoefDAC[4];</B>
   <B>USHORT Custom[32];</B>
<B>} PLATA_DESCR , *PPLATA_DESCR;</B></PRE><P>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>char SerNum[9] </B>- серийный номер платы; <BR><B>char
	BrdName[5] </B>- название платы; <BR><B>char Rev </B>- ревизия
	платы; <BR><B>char DspType[5] </B>- тип DSP; <BR><B>long Quartz </B>-
	частота кварца; <BR><B>USHORT IsDacPresent </B>- наличие ЦАПа;
	<BR><B>USHORT Reserv1[7] </B>- зарезервировано; <BR><B>USHORT
	KoefADC[8] </B>- калибровочные коэффициенты АЦП; <BR><B>USHORT
	KoefDAC[4] </B>- калибровочные коэффициенты ЦАП; <BR><B>USHORT
	Custom[32] </B>- пользовательское место; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>PLATA_DESCR_1450</H4>

<P>Структура описывает FLASH на ISA плате L-1450. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> 
	</P>
	<PRE><B>typedef struct __PLATA_DESCR_1450</B>
<B>{</B>
   <B>char SerNum[9];</B>
   <B>char BrdName[7];</B>
   <B>char Rev;</B>
   <B>char DspType[5];</B>
   <B>char IsDacPresent;</B>
   <B>char IsExtMemPresent;</B>
   <B>long Quartz;</B>
   <B>USHORT Reserv1[6];</B>
   <B>USHORT KoefADC[8];</B>
   <B>USHORT KoefDAC[4];</B>
   <B>USHORT Custom[32];</B>
<B>} PLATA_DESCR_1450 , *PPLATA_DESCR_1450;</B></PRE><P>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>char SerNum[9] </B>- серийный номер платы; <BR><B>char
	BrdName[7] </B>- название платы; <BR><B>char Rev </B>- ревизия
	платы; <BR><B>char DspType[5] </B>- тип DSP; <BR><B>char
	IsDacPresent </B>- наличие ЦАПа; <BR><B>char IsExtMemPresent </B>-
	наличие внешней памяти данных; <BR><B>long Quartz </B>- частота
	кварца; <BR><B>USHORT Reserv1[6] </B>- зарезервировано; <BR><B>USHORT
	KoefADC[8] </B>- калибровочные коэффициенты АЦП; <BR><B>USHORT
	KoefDAC[4] </B>- калибровочные коэффициенты ЦАП; <BR><B>USHORT
	Custom[32] </B>- пользовательское место; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>PLATA_DESCR_L791</H4>

<P>Структура описывает FLASH на PCI плате L-791. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> 
   </P>
   <PRE><B>typedef struct __PLATA_DESCR_L791</B>
<B>{</B>
   <B>USHORT crc;</B>
   <B>char SerNum[16];</B>
   <B>char BrdName[16];</B>
   <B>char Rev;</B>
   <B>char DspType[5];</B>
   <B>long Quartz;</B>
   <B>USHORT IsDacPresent;</B>
   <B>float KoefADC[16];</B>
   <B>float KoefDAC[4];</B>
   <B>USHORT Custom;</B>
<B>} PLATA_DESCR_L791 , *PPLATA_DESCR_L791;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>char SerNum[16] </B>- серийный номер платы; <BR><B>char
   BrdName[16] </B>- название платы; <BR><B>char Rev </B>- ревизия
   платы; <BR><B>char DspType[5] </B>- тип DSP; <BR><B>USHORT
   IsDacPresent </B>- наличие ЦАПа; <BR><B>long Quartz </B>- частота
   кварца; <BR><B>float KoefADC[16] </B>- калибровочные коэффициенты
   АЦП; <BR><B>float</B> <B>KoefDAC[4] </B>- калибровочные коэффициенты
   ЦАП; <BR><B>USHORT Custom </B>- пользовательское место; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P><FONT COLOR="#000000">Данная структура используется в интерфейсных
функциях, которые работают со служебной областью пользовательского
ППЗУ: <B>ReadPlataDescr</B> и <B>WritePlataDescr</B>.</FONT></P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=4 CELLSPACING=3>
   <COL WIDTH=54*>
   <COL WIDTH=202*>
   <THEAD>
      <TR VALIGN=TOP>
         <TH WIDTH=21%>
            <P>Название поля</P>
         </TH>
         <TH WIDTH=79%>
            <P STYLE="font-style: normal"><B><FONT SIZE=3><FONT FACE="Times New Roman">Назначение
            и допустимые значения поля</FONT></FONT> </B>
            </P>
         </TH>
      </TR>
   </THEAD>
   <TBODY>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER>crc</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm"><FONT FACE="Times New Roman">Контрольная
            сумма, расчитанная по всем полям структуры.</FONT></P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER><SPAN LANG="en-US"><FONT SIZE=3><FONT FACE="Times New Roman">SerNum</FONT></FONT></SPAN>
                        </P>
         </TD>
         <TD WIDTH=79%>
            <P><FONT SIZE=3><FONT FACE="Times New Roman">Серийный номер</FONT></FONT>
            <FONT SIZE=3><FONT FACE="Times New Roman">модуля (строка символов
            максимальной с длиной 16)</FONT></FONT></P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER><SPAN LANG="en-US"><FONT SIZE=3><FONT FACE="Times New Roman">BrdName</FONT></FONT></SPAN>
                        </P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm"><FONT FACE="Times New Roman">Название
            модуля (строка символов максимальной с длиной 16)</FONT></P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER><SPAN LANG="en-US"><FONT SIZE=3><FONT FACE="Times New Roman">Rev</FONT></FONT></SPAN>
                        </P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm"><FONT FACE="Times New Roman">Ревизия
            модуля (<SPAN LANG="en-US">ascii</SPAN></FONT> <FONT FACE="Times New Roman">символ)</FONT></P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER><SPAN LANG="en-US"><FONT SIZE=3><FONT FACE="Times New Roman">DspType</FONT></FONT></SPAN>
                        </P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm"><FONT FACE="Times New Roman">Тип
            используемого в модуле процессора (строка символов с максимальной
            длиной 16)</FONT></P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER><SPAN LANG="en-US"><FONT SIZE=3><FONT FACE="Times New Roman">Quartz</FONT></FONT></SPAN>
                        </P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm"><FONT FACE="Times New Roman">Частота
            задающего кварца (32-х разрядное целое)</FONT></P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER><SPAN LANG="en-US"><FONT SIZE=3><FONT FACE="Times New Roman">IsDacPresented</FONT></FONT></SPAN>
                        </P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm"><FONT FACE="Times New Roman">Флаг
            наличия ЦАП в модуле (логическая величина)</FONT></P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc[</SPAN>0]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции смещения нуля
            АЦП. Усилении &lsquo;<SPAN LANG="en-US">x</SPAN>1&rsquo;. (число
            с плавающей точкой одинарной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[1]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции смещения нуля
            АЦП. Усилении &lsquo;<SPAN LANG="en-US">x</SPAN>2&rsquo;.(число с
            плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[2]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции смещения нуля
            АЦП. Усилении &lsquo;<SPAN LANG="en-US">x</SPAN>4&rsquo;.(число с
            плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[<SPAN LANG="en-US">3</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции смещения нуля
            АЦП. Усилении &lsquo;<SPAN LANG="en-US">x8</SPAN>&rsquo;.(число с
            плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[<SPAN LANG="en-US">4</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции смещения нуля
            АЦП. Усилении &lsquo;<SPAN LANG="en-US">x16</SPAN>&rsquo;.(число
            с плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[<SPAN LANG="en-US">5</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции смещения нуля
            АЦП. Усилении &lsquo;<SPAN LANG="en-US">x32</SPAN>&rsquo;.(число
            с плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[<SPAN LANG="en-US">6</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции смещения нуля
            АЦП. Усилении &lsquo;<SPAN LANG="en-US">x6</SPAN>4&rsquo;.(число
            с плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[<SPAN LANG="en-US">7</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции смещения нуля
            АЦП. Усилении &lsquo;<SPAN LANG="en-US">x128</SPAN>&rsquo;.(число
            с плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[<SPAN LANG="en-US">8</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции масштаба АЦП.
            Усилении &lsquo;<SPAN LANG="en-US">x</SPAN>1&rsquo;. (число с
            плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[<SPAN LANG="en-US">9</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции масштаба АЦП.
            Усилении &lsquo;<SPAN LANG="en-US">x2</SPAN>&rsquo;. (число с
            плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[<SPAN LANG="en-US">10</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции масштаба АЦП.
            Усилении &lsquo;<SPAN LANG="en-US">x4</SPAN>&rsquo;. (число с
            плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[<SPAN LANG="en-US">11</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции масштаба АЦП.
            Усилении &lsquo;<SPAN LANG="en-US">x5</SPAN>&rsquo;. (число с
            плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[<SPAN LANG="en-US">12</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции масштаба АЦП.
            Усилении &lsquo;<SPAN LANG="en-US">x16</SPAN>&rsquo;.(число с
            плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[1<SPAN LANG="en-US">3</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции масштаба АЦП.
            Усилении &lsquo;<SPAN LANG="en-US">x32</SPAN>&rsquo;. (число с
            плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[1<SPAN LANG="en-US">4</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции масштаба АЦП.
            Усилении &lsquo;<SPAN LANG="en-US">x64</SPAN>&rsquo;.(число с
            плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefAdc</SPAN>[1<SPAN LANG="en-US">5</SPAN>]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции масштаба АЦП.
            Усилении &lsquo;<SPAN LANG="en-US">x128</SPAN>&rsquo;. (число с
            плавающей точкой двойной точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefDac</SPAN>[0]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции смещения нуля
            ЦАП. Канал &lsquo;0&rsquo;. (число с плавающей точкой двойной
            точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefDac</SPAN>[1]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции смещения нуля
            ЦАП. Канал &lsquo;1&rsquo;. (число с плавающей точкой двойной
            точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefDac</SPAN>[2]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции масштаба ЦАП.
            Канал &lsquo;0&rsquo;. (число с плавающей точкой двойной
            точности)</P>
         </TD>
      </TR>
      <TR VALIGN=TOP>
         <TD WIDTH=21%>
            <P ALIGN=CENTER STYLE="margin-top: 0.21cm"><SPAN LANG="en-US">KoefDac</SPAN>[3]</P>
         </TD>
         <TD WIDTH=79%>
            <P STYLE="margin-top: 0.21cm">Коэффициент коррекции масштаба ЦАП.
            Канал &lsquo;1&rsquo;.(число с плавающей точкой двойной точности)</P>
         </TD>
      </TR>
   </TBODY>
</TABLE>
<P><BR><BR>
</P>
<P><B><FONT COLOR="#000000">Корректировка данных АЦП/ЦАП.</FONT></B></P>
<P>Схемотехника и использованные компоненты обеспечивают линейность
передаточной характеристики АЦП/ЦАП модуля. Однако, в виду отсутствия
автоматической коррекции как внутри модуля так и в штатной
<SPAN LANG="en-US">dll</SPAN>-библиотеки, показания АЦП/ЦАП могут
иметь некоторое смешение нуля и неточность в передаче масштаба.
Работа по коррекции показаний возлагается на пользовательское
приложение.</P>
<P>Для корректировки показаний АЦП/ЦАП можно воспользоваться
собственными калибровочными коэффициентами и формулами или штатными
коэффициентами.</P>
<P>Штатные коэффициенты вычисляются при наладке модуля на
производстве и хранятся в системном ППЗУ модуля. Для того чтобы ими
воспользоваться, необходимо:</P>
<P STYLE="margin-left: 2.28cm; text-indent: -0.64cm">-считать
системное ППЗУ модуля при помощи функции <B><FONT COLOR="#000000">ReadPlataDescr()</FONT>
</B>
</P>
<P STYLE="margin-left: 2.28cm; text-indent: -0.64cm">-из считанной
системной информации выбрать коэффициенты масштаба и смещения нуля
соответствующие диапазону измерения АЦП или номеру канала ЦАП (см.
описание структуры <B><FONT COLOR="#000000">PLATA_DESCR_L791</FONT></B>)</P>
<P STYLE="margin-left: 2.28cm; text-indent: -0.64cm">-воспользоваться
приведенной ниже формулой:</P>
<P><BR><BR>
</P>
<P><B><U>Корректировка данных АЦП:</U></B></P>
<P STYLE="margin-left: 2cm; margin-top: 0.21cm"><B><SPAN LANG="en-US">Y</SPAN></B>
<SPAN LANG="en-US">= <B>(X+B)*A, </B></SPAN>где<SPAN LANG="en-US">: </SPAN>
</P>
<P STYLE="margin-left: 2cm"><B><SPAN LANG="en-US">X</SPAN></B> &ndash;
некорректированные данные АЦП [в отсчетах АЦП]</P>
<P STYLE="margin-left: 2cm"><B><SPAN LANG="en-US">Y</SPAN></B> &ndash;
скорректированные данные АЦП [в отсчетах АЦП]</P>
<P STYLE="margin-left: 2cm"><B><SPAN LANG="en-US">A</SPAN></B> &ndash;
коэффициент масштаба [безразмерный]</P>
<P STYLE="margin-left: 2cm"><B><SPAN LANG="en-US">B</SPAN></B> &ndash;
коэффициент смещение нуля [в отсчетах АЦП]</P>
<P><BR><BR>
</P>
<P><B><U>Примечание</U>:</B> Коэффициенты <B><SPAN LANG="en-US">A</SPAN></B>
и <B><SPAN LANG="en-US">B</SPAN></B> одни и те же для всех каналов
АЦП, но различные для разных диапазонов измерения.</P>
<P><B><U>Корректировка данных ЦАП:</U></B></P>
<P STYLE="margin-left: 2cm; margin-top: 0.21cm"><B><SPAN LANG="en-US">Y</SPAN></B>
<SPAN LANG="en-US">= <B>(X+B)*A ,</B></SPAN> где: 
</P>
<P STYLE="margin-left: 2cm"><B><SPAN LANG="en-US">X</SPAN></B> &ndash;
некорректированные данные ЦАП [в отсчетах ЦАП]</P>
<P STYLE="margin-left: 2cm"><B><SPAN LANG="en-US">Y</SPAN></B> &ndash;
корректированные данные ЦАП [в отсчетах ЦАП]</P>
<P STYLE="margin-left: 2cm"><B><SPAN LANG="en-US">A</SPAN></B> &ndash;
коэффициент масштаба [безразмерный]</P>
<P STYLE="margin-left: 2cm"><B><SPAN LANG="en-US">B</SPAN></B> &ndash;
коэффициент смещение нуля [в отсчетах ЦАП]</P>
<P><BR><BR>
</P>
<P><U><B>Пример 1:</B></U></P>
<P>С АЦП, настроенного на диапазон <FONT FACE="Symbol">&plusmn;</FONT>2.5В
(усиление х4), получены следующие данные: 
</P>
<P><B><SPAN LANG="en-US">X</SPAN><SUB>1</SUB></B>=1000, <B><SPAN LANG="en-US">X</SPAN><SUB>2</SUB></B>=-1000,
<B><SPAN LANG="en-US">X</SPAN><SUB>3</SUB></B>=0</P>
<P>тогда, если положить что <B><SPAN LANG="en-US">pd</SPAN></B> &ndash;
структура типа <B><FONT COLOR="#000000">PLATA_DESCR_L791
</FONT></B>предварительно участвовавшая в вызове функции
<B><FONT COLOR="#000000">ReadPlataDescr()</FONT></B>, то коэффициенты
коррекции и скорректированные данные можно получить так:</P>
<P STYLE="margin-left: 2cm"><SPAN LANG="en-US"><B>A</B>=<B>pd.
KoefAdc[</B>10<B>], B</B>=<B>pd. KoefADC [</B>2<B>]</B></SPAN></P>
<P STYLE="margin-left: 2cm"><SPAN LANG="en-US"><B>Y<SUB>1</SUB></B>=(<B>B</B>+1000)*<B>A,</B>
<B>Y<SUB>2</SUB></B>=(<B>B</B>-1000)*<B>A,</B> <B>Y<SUB>3</SUB></B>=<B>B</B>*<B>A</B></SPAN></P>
<P><U><B>Пример 2:</B></U></P>
<P>На втором канале ЦАП необходимо выставить напряжение,
соответствующее следующим кодам: 
</P>
<P><B><SPAN LANG="en-US">X</SPAN><SUB>1</SUB></B>=1000, <B><SPAN LANG="en-US">X</SPAN><SUB>2</SUB></B>=-1000,
<B><SPAN LANG="en-US">X</SPAN><SUB>3</SUB></B>=0</P>
<P>тогда, если положить что <B><SPAN LANG="en-US">pd</SPAN></B> &ndash;
структура типа <B><FONT COLOR="#000000">PLATA_DESCR_L791</FONT></B>
предварительно участвовавшая в вызове функции<FONT COLOR="#0000ff">
</FONT><B><FONT COLOR="#000000">ReadPlataDescr()</FONT></B>, то
коэффициенты коррекции и данные, которые необходимо записать во
второй канал ЦАП, можно получить так:</P>
<P STYLE="margin-left: 2cm"><SPAN LANG="en-US"><B>A</B>=<B>pd.
KoefDac[</B>3<B>],</B> <B>B</B>=<B>pd. KoefDac[</B>1<B>]</B></SPAN></P>
<P STYLE="margin-left: 2cm"><SPAN LANG="en-US"><B>Y<SUB>1</SUB></B>=(<B>B</B>+1000)*<B>A,</B>
<B>Y<SUB>2</SUB></B>=(<B>B</B>-1000)*<B>A,</B> <B>Y<SUB>3</SUB></B>=<B>B</B>*<B>A</B></SPAN></P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>

<br clear=all style='page-break-before:always'>
<H4>PLATA_DESCR_E440</H4>

<P>Структура описывает FLASH на USB модуле E14-440. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> 
   </P>
   <PRE><B>typedef struct __PLATA_DESCR_440</B>
<B>{</B>
   <B>char SerNum[9];</B>
   <B>char BrdName[7];</B>
   <B>char Rev;</B>
   <B>char DspType[5];</B>
   <B>char IsDacPresent;</B>
   <B>long Quartz;</B>
   <B>char Reserv2[13];</B>
   <B>USHORT KoefADC[8];</B>
   <B>USHORT KoefDAC[4];</B>
   <B>USHORT Custom[32];</B>
<B>} PLATA_DESCR_E440 , *PPLATA_DESCR_E440;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>char SerNum[9] </B>- серийный номер платы; <BR><B>char
   BrdName[7] </B>- название платы; <BR><B>char Rev </B>- ревизия
   платы; <BR><B>char DspType[5] </B>- тип DSP; <BR><B>long Quartz </B>-
   частота кварца; <BR><B>char IsDacPresent </B>- наличие ЦАПа; <BR><B>char
   Reserv2[13] </B>- зарезервировано; <BR><B>USHORT KoefADC[8] </B>-
   калибровочные коэффициенты АЦП; <BR><B>USHORT KoefDAC[4] </B>-
   калибровочные коэффициенты ЦАП; <BR><B>USHORT Custom[32] </B>-
   пользовательское место; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>PLATA_DESCR_E140</H4>

<P>Структура описывает FLASH на USB модуле E14-140. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> 
   </P>
   <PRE><B>typedef struct __PLATA_DESCR_E140</B>
<B>{</B>
   <B>char SerNum[9];</B>
   <B>char BrdName[11];</B>
   <B>char Rev;</B>
   <B>char DspType[11];</B>
   <B>char IsDacPresent;</B>
   <B>long Quartz;</B>
   <B>char Reserv2[3];</B>
   <B>float KoefADC[8];</B>
   <B>float KoefDAC[4];</B>
   <B>USHORT Custom[20];</B>
<B>} PLATA_DESCR_E140 , *PPLATA_DESCR_E140;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>char SerNum[9] </B>- серийный номер платы; <BR><B>char
   BrdName[11] </B>- название платы; <BR><B>char Rev </B>- ревизия
   платы; <BR><B>char DspType[11] </B>- тип DSP; <BR><B>long Quartz </B>-
   частота кварца; <BR><B>char IsDacPresent </B>- наличие ЦАПа; <BR><B>char
   Reserv2[3] </B>- зарезервировано; <BR><B>float KoefADC[8] </B>-
   калибровочные коэффициенты АЦП; <BR><B>float KoefDAC[4] </B>-
   калибровочные коэффициенты ЦАП; <BR><B>USHORT Custom[20] </B>-
   пользовательское место; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P><FONT COLOR="#000000">Внутри модуля это все храниться в ужасном
формате PACKED_PLATA_DESCR_E140 котрый определен в файле ioctl.h. Но
от пользователя это все скрыто и знать об этом не обязательно...</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>PLATA_DESCR_E154</H4>

<P>Структура описывает FLASH на USB модуле E154. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> 
   </P>
   <PRE><B>typedef struct __PLATA_DESCR_E154</B>
<B>{</B>
   <B>char SerNum[9];</B>
   <B>char BrdName[11];</B>
   <B>char Rev;</B>
   <B>char DspType[11];</B>
   <B>char IsDacPresent;</B>
   <B>long Quartz;</B>
   <B>char Reserv2[3];</B>
   <B>float KoefADC[8];</B>
   <B>float KoefDAC[4];</B>
   <B>USHORT Custom[20];</B>
<B>} PLATA_DESCR_E154 , *PPLATA_DESCR_E154;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>char SerNum[9] </B>- серийный номер платы; <BR><B>char
   BrdName[11] </B>- название платы; <BR><B>char Rev </B>- ревизия
   платы; <BR><B>char DspType[11] </B>- тип DSP; <BR><B>long Quartz </B>-
   частота кварца; <BR><B>char IsDacPresent </B>- наличие ЦАПа; <BR><B>char
   Reserv2[3] </B>- зарезервировано; <BR><B>float KoefADC[8] </B>-
   калибровочные коэффициенты АЦП; <BR><B>float KoefDAC[4] </B>-
   калибровочные коэффициенты ЦАП; <BR><B>USHORT Custom[20] </B>-
   пользовательское место; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P><FONT COLOR="#000000">Внутри модуля это все храниться в ужасном
формате PACKED_PLATA_DESCR_E154 котрый определен в файле ioctl.h. Но
от пользователя это все скрыто и знать об этом не обязательно...</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>PLATA_DESCR_E2010</H4>

<P>Структура описывает FLASH на USB модуле E20-10. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
   <P><FONT COLOR="#ff0000">C:</FONT> 
   </P>
   <PRE><B>typedef struct __PLATA_DESCR_E2010</B>
<B>{</B>
   <B>char BrdName[16];</B>
   <B>char SerNum[16];</B>
   <B>char DspType[16];</B>
   <B>long Quartz;</B>
   <B>char Rev;</B>
   <B>char IsDacPresent;</B>
   <B>float KoefADC[24];</B>
   <B>float KoefDAC[4];</B>
   <B>USHORT Custom[45];</B>
<B>} PLATA_DESCR_E2010 , *PPLATA_DESCR_E2010;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
   <P><B>char SerNum[16] </B>- серийный номер платы; <BR><B>char
   BrdName[16] </B>- название платы; <BR><B>char Rev </B>- ревизия
   платы; <BR><B>char DspType[16] </B>- тип DSP; <BR><B>long Quartz </B>-
   частота кварца; <BR><B>char IsDacPresent </B>- наличие ЦАПа; <BR><B>float
   KoefADC[24] </B>- калибровочные коэффициенты АЦП; <BR><B>float
   KoefDAC[4] </B>- калибровочные коэффициенты ЦАП; <BR><B>USHORT
   Custom[45] </B>- пользовательское место; 
   </P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P><BR><BR>
</P>

<br clear=all style='page-break-before:always'>
<H4>PLATA_DESCR_U</H4>

<P>Это обобщенная структура для удобства работы с флешами разных
плат. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> 
	</P>
	<PRE><B>typedef union __PLATA_DESCR_U</B>
<B>{</B>
   <B>PLATA_DESCR t1;</B>
   <B>PLATA_DESCR_1450 t2;</B>
   <B>PLATA_DESCR_L791 t3;</B>
   <B>WORD_IMAGE wi; </B>
        <B>BYTE-IMAGE bi; </B>
<B>} PLATA_DESCR_U, *PPLATA_DESCR_U;</B>

<B>typedef union __PLATA_DESCR_U2</B>
<B>{</B>
   <B>PLATA_DESCR t1;</B>
   <B>PLATA_DESCR_1450 t2;</B>
   <B>PLATA_DESCR_L791 t3;</B>
   <B>PLATA_DESCR_E440 t4;</B>
   <B>PLATA_DESCR_E140 t5;</B>
   <B>PACKED_PLATA_DESCR_E140 pt5;</B>
   <B>PLATA_DESCR_E2010 t6;</B>
   
   <B>WORD_IMAGE wi;</B>
   <B>BYTE_IMAGE bi;</B>
   <B>WORD_IMAGE_256 wi256;</B>
   <B>BYTE_IMAGE_256 bi256;    </B>
<B>} PLATA_DESCR_U2, *PPLATA_DESCR_U2;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P><FONT COLOR="#000000">Структура  PLATA_DESCR_U2 дополнена новыми
типами данных для новых модулей и расширена до 256 байт против 128.
Библиотека внутри хранит все уже в структуре U2.</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>WORD_IMAGE</H4>

<P>Представление структуры флеша в виде массива слов. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> 
	</P>
	<PRE><B>typedef struct __WORD_IMAGE</B>
<B>{</B>
   <B>WORD data[64];</B>
<B>} WORD_IMAGE, *PWORD_IMAGE;</B></PRE><P>
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>

<br clear=all style='page-break-before:always'>
<H4>SLOT_PAR</H4>

<P>Структура описывает параметры виртуального слота. 
</P>
<P><FONT COLOR="#0000ff">Описание:</FONT></P>
<UL>
	<P><FONT COLOR="#ff0000">C:</FONT> 
	</P>
	<PRE><B>typedef struct __SLOT_PARAM</B>
<B>{</B>
   <B>ULONG Base;</B>
   <B>ULONG BaseL;</B>
   <B>ULONG Base1;</B>
   <B>ULONG BaseL1;</B>
   <B>ULONG Mem;</B>
   <B>ULONG MemL;</B>
   <B>ULONG Mem1;</B>
   <B>ULONG MemL1;</B>
   <B>ULONG Irq;</B>
   <B>ULONG BoardType;</B>
   <B>ULONG DSPType;</B>
   <B>ULONG Dma;</B>
   <B>ULONG DmaDac;</B>
   <B>ULONG DTA_REG;</B>
   <B>ULONG IDMA_REG;</B>
   <B>ULONG CMD_REG;</B>
   <B>ULONG IRQ_RST;</B>
   <B>ULONG DTA_ARRAY;</B>
   <B>ULONG RDY_REG;</B>
   <B>ULONG CFG_REG;</B>
<B>} SLOT_PAR, *PSLOT_PAR;</B></PRE>
</UL>
<P><FONT COLOR="#0000ff">Параметры:</FONT></P>
<UL>
	<P><B>ULONG Base </B>- базовый адрес первого региона портов; <BR><B>ULONG
	BaseL </B>- протяженность первого региона портов в байтах; <BR><B>ULONG
	Base1 </B>- базовый адрес второго региона портов; <BR><B>ULONG
	BaseL1 </B>- протяженность второго региона портов в байтах; <BR><B>ULONG
	Mem </B>- адрес первого региона памяти; <BR><B>ULONG MemL </B>-
	протяженность первого региона памяти в байтах; <BR><B>ULONG Mem1 </B>-
	адрес второго региона памяти; <BR><B>ULONG MemL1 </B>- протяженность
	второго региона памяти в байтах; <BR><B>ULONG Irq </B>- используемое
	драйвером аппаратное прерывание; <BR><B>ULONG BoardType </B>- тип
	платы; <BR><B>ULONG DSPType </B>- тип установленного на плате DSP;
	<BR><B>ULONG Dma </B>- используемый для ввода данных канал ПДП: 0 -
	не использовать,5,6; <BR><B>ULONG DmaDac </B>- используемый для
	вывода данных канал ПДП: 0 - не использовать,6; <BR><B>ULONG
	DTA_REG;<BR>ULONG IDMA_REG;<BR>ULONG CMD_REG;<BR>ULONG
	IRQ_RST;<BR>ULONG DTA_ARRAY;<BR>ULONG RDY_REG;<BR>ULONG CFG_REG; </B>-
	адреса регистров платы относительного базового адреса; 
	</P>
</UL>
<P><FONT COLOR="#0000ff">Примечание:</FONT></P>
<P>Структура SLOT_PAR используется совместно с вызовом GetSlotParam
для получения параметров виртуальных слотов. 
</P>
<P>Для платы L791 занчение имеют только поля Mem, MemL, Irq,
BoardType. Все остальные ничего не значат.</P>

<br clear=all style='page-break-before:always'>
<H4>Коды ошибок</H4>

<P>Пока определены следующие коды ошибок: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_SUCCESS 0</B> - функция
	выполнена успешно; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_NOTSUPPORTED 1</B> - функция
	не поддерживается этой платой; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_ERROR 2</B> - ошибка при
	выполнении функции; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_ERROR_NOBOARD 3</B> - нет
	платы в запрашиваемом слоте; 
	</P>
	<LI><P><B>L_ERROR_INUSE 4</B> &ndash; плата в запрашиваемом слоте
	уже используется; 
	</P>
</UL>

<br clear=all style='page-break-before:always'>
<H4>Типы плат</H4>

<P>В заголовочных файлах определены следующие типы плат
поддерживаемые библиотекой: 
</P>
<UL>
	<LI><P ALIGN=LEFT><B>NONE 0</B> - нет платы;</P>
	<LI><P ALIGN=LEFT><B>L1250 1</B> - плата L1250;</P>
	<LI><P ALIGN=LEFT><B>N1250 2</B> - плата N1250 (работоспособность не
	проверялась);</P>
	<LI><P ALIGN=LEFT><B>L1251 3</B> - плата L1251;</P>
	<LI><P ALIGN=LEFT><B>L1221 4</B> - плата L1221; 
	</P>
	<LI><P ALIGN=LEFT><B>PCIA 5</B> - плата серии L7XX rev. A;</P>
	<LI><P ALIGN=LEFT><B>PCIB 6</B> - плата серии L7XX rev. B;</P>
	<LI><P ALIGN=LEFT><B>L264 8</B> - плата L264;</P>
	<LI><P ALIGN=LEFT><B>L305 9</B> - плата L305;</P>
	<LI><P ALIGN=LEFT><B>L1450C 10</B> - плата L1450 с совместимым
	биосом L1250;</P>
	<LI><P ALIGN=LEFT><B>L1450 11</B> - плата L1450;</P>
	<LI><P ALIGN=LEFT><B>L032 12</B> - плата L032;</P>
	<LI><P ALIGN=LEFT><B>HI8 13</B> - плата HI8;</P>
	<LI><P ALIGN=LEFT><B>PCIC 14</B> - плата серии L7XX rev. С (L780M);</P>
	<LI><P ALIGN=LEFT><B>L791 19</B> - плата серии L79X (L791);</P>
	<LI><P ALIGN=LEFT><B>E440 30</B> - модуль E14-440;</P>
	<LI><P ALIGN=LEFT><B>E140 31</B> - модуль E14-140;</P>
	<LI><P ALIGN=LEFT><B>E2010 32</B> &ndash; модуль E20-10;</P>
	<LI><P ALIGN=LEFT><B>E154 38</B> &ndash; модуль E154;</P>
	<LI><P ALIGN=LEFT><B>E2010B 39</B> &mdash; модуль E20-10 ревизии В</P>
</UL>

<br clear=all style='page-break-before:always'>
<H4>Другие константы</H4>

<P>В заголовочных файлах определены следующие константы: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_ADC_PARAM 1</B> - трактовать
	DAQ_PAR как ADC_PAR при передаче в FillDAQparameters; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_DAC_PARAM 2</B> - трактовать
	DAQ_PAR как DAC_PAR при передаче в FillDAQparameters; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_ASYNC_ADC_CFG 3</B> -
	ASYNC_PAR содержит запрос на конфигурирование АЦП; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_ASYNC_TTL_CFG 4</B> -
	ASYNC_PAR содержит запрос на конфигурирование цифровых линий; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_ASYNC_DAC_CFG 5</B> -
	ASYNC_PAR содержит запрос на конфигурирование ЦАП; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_ASYNC_ADC_INP 6</B> -
	ASYNC_PAR содержит запрос на ввод данных с АЦП; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_ASYNC_TTL_INP 7</B> -
	ASYNC_PAR содержит запрос на ввод данных с цифровых линий; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_ASYNC_TTL_OUT 8</B> -
	ASYNC_PAR содержит запрос на вывод данных на цифровые линии; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_ASYNC_DAC_OUT 9</B> -
	ASYNC_PAR содержит запрос на вывод данных на ЦАП; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"></P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_STREAM_ADC 1</B> - тип потока
	- поток данных с АЦП; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_STREAM_DAC 2</B> - тип потока
	- поток данных с ЦАП; 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"></P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_EVENT_ADC_BUF 1</B></P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_EVENT_DAC_BUF 2</B></P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_EVENT_ADC_OVF 3</B></P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_EVENT_ADC_FIFO 4</B></P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_EVENT_DAC_USER 5</B></P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_EVENT_DAC_UNF 6</B></P>
	<LI><P STYLE="margin-bottom: 0cm"><B>L_EVENT_PWR_OVR 7</B> &ndash;
	макросы для различных событий устанавливаемых в функции
	SetLDeviceEvent для платы L791.</P>
</UL>

<br clear=all style='page-break-before:always'>
<H2>Справочные данные по платам</H2>
<H3>Адресное пр-во и команды биос L-1250/L-264/L-305</H3>

<P>Адресное пространство L-1250/L-264/L-305 
</P>
<TABLE COLS=3 WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P>Адрес</P>
		</TD>
		<TD>
			<P>Чтение</P>
		</TD>
		<TD>
			<P>Запись</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+0x0</P>
		</TD>
		<TD>
			<P>Данные от платы. До тех пор, пока процессор ADSP ничего не
			записал в порт данных, соответствующий бит готовности равен нулю.
			После записи слова в порт данных процессором ADSP автоматически
			устанавливается в единичное значение бит готовности, который
			переключится в ноль после того, как компьютер считает переданное
			слово. 
			</P>
		</TD>
		<TD>
			<P>Данные для передачи в плату. После записи слова в порт данных
			автоматически устанавливается в нулевое значение бит готовности,
			который переключится в единицу автоматически после того, как
			процессор ADSP считает переданное слово. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+0x8</P>
		</TD>
		<TD>
			<P>Сброс прерывания от платы в PC. В том случае если используется
			прерывание IRQ10/11, то обработчик прерывания обязан произвести
			одно чтение из этого порта для сброса запроса прерывания. В
			противном случае линия прерываний окажется заблокированной. 
			</P>
		</TD>
		<TD>
			<P>При записи команды в этот порт автоматически генерируется
			прерывание в процессоре ADSP IRQ2. Драйвер LBIOS использует это
			порт для передачи команд, при этом обработчик прерывания в
			процессоре в ответ на IRQ2 считывает переданный код через порт
			данных и вызывает функцию, соответствующую переданному коду. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+0xC</P>
		</TD>
		<TD>
			<P>Порт битов готовности и двух ТТЛ цифровых линий ( 34 и 35 на
			внешнем разъеме ) 
			</P>
		</TD>
		<TD>
			<P>Порт конфигурации. При помощи порта конфигурации можно: -
			загрузить в процессор управляющую программу; - отключить линию
			прерывания IRQ10/11; - перевести порт данных в режим работы по
			каналам ПДП; 
			</P>
		</TD>
	</TR>
</TABLE>
<P>Список команд поддерживаемых биос L-1250/L-264/L-305 
</P>
<TABLE COLS=3 WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P>Номер</P>
		</TD>
		<TD>
			<P>Обозначение</P>
		</TD>
		<TD>
			<P>Описание</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0</P>
		</TD>
		<TD>
			<P>cmSTOP_1251</P>
		</TD>
		<TD>
			<P>перевод платы в &quot;тихое&quot; состояние</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>1</P>
		</TD>
		<TD>
			<P>cmADC_CHAN_1251</P>
		</TD>
		<TD>
			<P>ввод с АЦП с переустановкой каналов</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>2</P>
		</TD>
		<TD>
			<P>cmOUT_DAC_1251</P>
		</TD>
		<TD>
			<P>вывод на ЦАП</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>3</P>
		</TD>
		<TD>
			<P>cmSTREAM_1251</P>
		</TD>
		<TD>
			<P>одноканальный ввод с синхронизацией от внутреннего таймера</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>4</P>
		</TD>
		<TD>
			<P>cmSOFT_1251</P>
		</TD>
		<TD>
			<P>многоканальный ввод с синхронизацией от внутреннего таймера</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>5</P>
		</TD>
		<TD>
			<P>cmSAMPLE_1251</P>
		</TD>
		<TD>
			<P>ввод с АЦП без переустановки каналов</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>6</P>
		</TD>
		<TD>
			<P>cmTTL_IN_1251</P>
		</TD>
		<TD>
			<P>ввод цифровых портов</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>7</P>
		</TD>
		<TD>
			<P>cmTTL_OUT_1251</P>
		</TD>
		<TD>
			<P>вывод в цифровые порты</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>8</P>
		</TD>
		<TD>
			<P>cmIRQ_SIMPLE_1251</P>
		</TD>
		<TD>
			<P>генерирование прерываний от внутреннего таймера</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>9</P>
		</TD>
		<TD>
			<P>cmIRQ_ADC_CHAN_1251</P>
		</TD>
		<TD>
			<P>генерирование прерываний от внутреннего таймера с одноканальным
			вводом с АЦП</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>10</P>
		</TD>
		<TD>
			<P>cmIRQ_KADR_1251</P>
		</TD>
		<TD>
			<P>генерирование прерываний от внутреннего таймера с
			многоканальным вводом с АЦП</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>11</P>
		</TD>
		<TD>
			<P>cmCALIBR_1251</P>
		</TD>
		<TD>
			<P>зарезервирована</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>12</P>
		</TD>
		<TD>
			<P>cmTEST_1251</P>
		</TD>
		<TD>
			<P>тестирование наличия платы</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>13</P>
		</TD>
		<TD>
			<P>cmDAC_STREAM_1251</P>
		</TD>
		<TD>
			<P>вывод на ЦАП массива</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>14</P>
		</TD>
		<TD>
			<P>cmMEMORY_STATE_1251</P>
		</TD>
		<TD>
			<P>тестирование памяти</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>15</P>
		</TD>
		<TD>
			<P>cmFILTER_1251</P>
		</TD>
		<TD>
			<P>зарезервирована</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>16</P>
		</TD>
		<TD>
			<P>cmFLT_NO_LOAD_1251</P>
		</TD>
		<TD>
			<P>зарезервирована</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>17</P>
		</TD>
		<TD>
			<P>cmSET_MULTI_1251</P>
		</TD>
		<TD>
			<P>зарезервирована</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>18</P>
		</TD>
		<TD>
			<P>cmSET_SCALE_1251</P>
		</TD>
		<TD>
			<P>установка коэффициента масштабирования таймера</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>19</P>
		</TD>
		<TD>
			<P>cmSET_UVX_1251</P>
		</TD>
		<TD>
			<P>зарезервирована</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>20</P>
		</TD>
		<TD>
			<P>cmSET_DSP_SPEED_1251</P>
		</TD>
		<TD>
			<P>установка типа скорости процессора</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>21</P>
		</TD>
		<TD>
			<P>cmSET_WAITSTATE_1251</P>
		</TD>
		<TD>
			<P>установка задержки на память</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>22</P>
		</TD>
		<TD>
			<P>cmSET_DELAY_1251</P>
		</TD>
		<TD>
			<P>установка межканальной задержки</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>23</P>
		</TD>
		<TD>
			<P>cmSYNCHRO_MODE_1251</P>
		</TD>
		<TD>
			<P>установка типа синхронизации</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>24</P>
		</TD>
		<TD>
			<P>cmDAC_CONFIG_1251</P>
		</TD>
		<TD>
			<P>установка номера ЦАПа</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>25</P>
		</TD>
		<TD>
			<P>cmFIFO_CONFIG_1251</P>
		</TD>
		<TD>
			<P>режим FIFO буфера</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>26</P>
		</TD>
		<TD>
			<P>cmSOFT_MEMORY_1251</P>
		</TD>
		<TD>
			<P>ввод во внутреннюю память</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>28</P>
		</TD>
		<TD>
			<P>cmPROGRAM_1251</P>
		</TD>
		<TD>
			<P>программирование модулей в крейте</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>29</P>
		</TD>
		<TD>
			<P>cmWRITE_TO_MEM_1251</P>
		</TD>
		<TD>
			<P>ввод в память массива</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>30</P>
		</TD>
		<TD>
			<P>cmREAD_FROM_MEM_1251</P>
		</TD>
		<TD>
			<P>чтение массива из памяти</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>31</P>
		</TD>
		<TD>
			<P>cmGET_LSM_NAME_1251</P>
		</TD>
		<TD>
			<P>чтение кода модуля</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>32</P>
		</TD>
		<TD>
			<P>cmSET_2FIFO_TYPE_1251</P>
		</TD>
		<TD>
			<P>установка двойного FIFO</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>33</P>
		</TD>
		<TD>
			<P>cmSET_LM_DAC_1251</P>
		</TD>
		<TD>
			<P>установка ЦАПа LM модуля</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>34</P>
		</TD>
		<TD>
			<P>cmGET_LM_TTL_1251</P>
		</TD>
		<TD>
			<P>чтение цифрового модуля</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>35</P>
		</TD>
		<TD>
			<P>cmCOMPARATPR_1251</P>
		</TD>
		<TD>
			<P>частотомер</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>36</P>
		</TD>
		<TD>
			<P>cmTEST_PM_1251</P>
		</TD>
		<TD>
			<P>проверка наличия памяти программ</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>37</P>
		</TD>
		<TD>
			<P>cmLOW_POWER_1251</P>
		</TD>
		<TD>
			<P>cmLOW_POWER_1251</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>39</P>
		</TD>
		<TD>
			<P>cmLM404_1251</P>
		</TD>
		<TD>
			<P>работа с модулем LM-404</P>
		</TD>
	</TR>
</TABLE>
<P><BR><BR>
</P>

<br clear=all style='page-break-before:always'>
<H3>Адресное пр-во и команды биос L-7XX</H3>

<P>Существует две ревизии PCI плат - А и В. Они различаются
адресацией портов. Ревизия А очень редкая. Наиболее распространенная
ревизия &ndash; В. Base - один из трех возможных вариантов базового
адреса:порты ввода/вывода,память ниже 1Мб,память выше 1Мб.Значения
Base можно увидеть под Windows в Панели Управления/Система в ресурсах
соответствующих PCI плат. Под Windows всегда используется доступ к
плате через память выше 1Мб. 
</P>
<P>Адресное пространство L-761/L-780/L-783 (Rev A). 
</P>
<TABLE COLS=3 WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P>Адрес</P>
		</TD>
		<TD>
			<P>Чтение</P>
		</TD>
		<TD>
			<P>Запись</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+0</P>
		</TD>
		<TD>
			<P>Порт для чтения данных с платы по IDMA как при одиночных
			операция, так и при блочных. 
			</P>
		</TD>
		<TD>
			<P>Порт для записи данных в плату по IDMA как при одиночных
			операция, так и при блочных. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+4096</P>
		</TD>
		<TD>
			<P>- 
			</P>
		</TD>
		<TD>
			<P>Порт для установки адреса IDMA. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+8192</P>
		</TD>
		<TD>
			<P>- 
			</P>
		</TD>
		<TD>
			<P>Порт генерации IRQ2 DSP. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+12288</P>
		</TD>
		<TD>
			<P>- 
			</P>
		</TD>
		<TD>
			<P>Порт сброса прерываний. 
			</P>
		</TD>
	</TR>
</TABLE>
<P>Адресное пространство L-761/L-780/L-783 (Rev B). 
</P>
<TABLE COLS=3 WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P>Адрес</P>
		</TD>
		<TD>
			<P>Чтение</P>
		</TD>
		<TD>
			<P>Запись</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+0</P>
		</TD>
		<TD>
			<P>Порт для чтения данных с платы по IDMA при одиночных операция. 
			</P>
		</TD>
		<TD>
			<P>Порт для записи данных в плату по IDMA при одиночных операция. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+2</P>
		</TD>
		<TD>
			<P>- 
			</P>
		</TD>
		<TD>
			<P>Порт для установки адреса IDMA. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+4</P>
		</TD>
		<TD>
			<P>- 
			</P>
		</TD>
		<TD>
			<P>Порт генерации IRQ2 DSP. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+6</P>
		</TD>
		<TD>
			<P>- 
			</P>
		</TD>
		<TD>
			<P>Порт сброса прерываний. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+4096</P>
		</TD>
		<TD>
			<P>Порт для чтения данных с платы по IDMA при блочных операциях. 
			</P>
		</TD>
		<TD>
			<P>Порт для записи данных в плату по IDMA при блочных операциях. 
			</P>
		</TD>
	</TR>
</TABLE>
<P>Список команд поддерживаемых биос L-761/L-780/L-783 
</P>
<TABLE COLS=4 WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P>Номер</P>
		</TD>
		<TD>
			<P>Обозначение</P>
		</TD>
		<TD>
			<P>Описание</P>
		</TD>
		<TD>
			<P>Использует</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0</P>
		</TD>
		<TD>
			<P>cmTEST_PLX</P>
		</TD>
		<TD>
			<P>Проверка загрузки платы и ее работоспособности;</P>
		</TD>
		<TD>
			<P>L_TEST_LOAD_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>1</P>
		</TD>
		<TD>
			<P>cmLOAD_CONTROL_TABLE_PLX</P>
		</TD>
		<TD>
			<P>Загрузка управляющей таблицы в память DSP;</P>
		</TD>
		<TD>
			<P>L_CONTROL_TABLE_PLX, L_CONTROL_TABLE_LENGTH_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>2</P>
		</TD>
		<TD>
			<P>cmADC_ENABLE_PLX</P>
		</TD>
		<TD>
			<P>Разрешение/Запрещение работы АЦП;</P>
		</TD>
		<TD>
			<P>L_ADC_ENABLE_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>3</P>
		</TD>
		<TD>
			<P>cmADC_FIFO_CONFIG_PLX</P>
		</TD>
		<TD>
			<P>Конфигурирование параметров кольцевого буфера АЦП;</P>
		</TD>
		<TD>
			<P>L_ADC_FIFO_BASE_ADDRESS_PLX, L_ADC_FIFO_BASE_ADDRESS_INDEX_PLX,
			L_ADC_FIFO_LENGTH_PLX, L_ADC_NEW_FIFO_LENGTH_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>4</P>
		</TD>
		<TD>
			<P>cmSET_ADC_KADR_PLX</P>
		</TD>
		<TD>
			<P>Установка временных параметров работы АЦП;</P>
		</TD>
		<TD>
			<P>L_ADC_RATE_PLX, L_INTER_CADR_DELAY_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>5</P>
		</TD>
		<TD>
			<P>cmENABLE_DAC_STREAM_PLX</P>
		</TD>
		<TD>
			<P>Разрешение/запрещение выдачи данных из буфера ЦАП.</P>
		</TD>
		<TD>
			<P>L_DAC_ENABLE_STREAM_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>6</P>
		</TD>
		<TD>
			<P>cmDAC_FIFO_CONFIG_PLX</P>
		</TD>
		<TD>
			<P>Конфигурирование параметров буфера ЦАП;</P>
		</TD>
		<TD>
			<P>L_DAC_FIFO_BASE_ADDRESS_PLX, L_DAC_FIFO_LENGTH_PLX,
			L_DAC_NEW_FIFO_LENGTH_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>7</P>
		</TD>
		<TD>
			<P>cmSET_DAC_RATE_PLX</P>
		</TD>
		<TD>
			<P>Установка частоты вывода данных на ЦАП;</P>
		</TD>
		<TD>
			<P>L_DAC_RATE_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>8</P>
		</TD>
		<TD>
			<P>cmADC_SAMPLE_PLX</P>
		</TD>
		<TD>
			<P>Однократный ввод c АЦП;</P>
		</TD>
		<TD>
			<P>L_ADC_SAMPLE_PLX, L_ADC_CHANNEL_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>9</P>
		</TD>
		<TD>
			<P>cmTTL_IN_PLX</P>
		</TD>
		<TD>
			<P>Чтение данных с цифровых линий;</P>
		</TD>
		<TD>
			<P>L_TTL_IN_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>10</P>
		</TD>
		<TD>
			<P>cmTTL_OUT_PLX</P>
		</TD>
		<TD>
			<P>Вывод данных на цифровые линии;</P>
		</TD>
		<TD>
			<P>L_TTL_OUT_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>11</P>
		</TD>
		<TD>
			<P>cmSYNCHRO_CONFIG_PLX</P>
		</TD>
		<TD>
			<P>Управление синхронизацией;</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_TYPE_PLX, L_SYNCHRO_AD_CHANNEL_PLX,
			L_SYNCHRO_AD_POROG_PLX, L_SYNCHRO_AD_MODE_PLX,
			L_SYNCHRO_AD_SENSITIVITY_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>12</P>
		</TD>
		<TD>
			<P>cmENABLE_IRQ_PLX</P>
		</TD>
		<TD>
			<P>Разрешение/запрещение работы с прерываниями;</P>
		</TD>
		<TD>
			<P>L_ENABLE_IRQ_PLX, L_ENABLE_IRQ_VALUE_PLX, L_IRQ_STEP_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>13</P>
		</TD>
		<TD>
			<P>cmIRQ_TEST_PLX</P>
		</TD>
		<TD>
			<P>Тестовая команда генерирует прерывания 10 раз в сек;</P>
		</TD>
		<TD>
			<P>L_ENABLE_IRQ_PLX</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>14</P>
		</TD>
		<TD>
			<P>cmSET_DSP_TYPE_PLX</P>
		</TD>
		<TD>
			<P>Передает в драйвер тип установленного на плате DSP и
			соответствующим образом модифицирует код драйвера;</P>
		</TD>
		<TD>
			<P>L_DSP_TYPE_PLX</P>
		</TD>
	</TR>
</TABLE>
<P>Список внутренних переменных биос L-761/L-780/L-783 (8 - признак
того, что это DM) 
</P>
<TABLE COLS=3 WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P>Адрес</P>
		</TD>
		<TD>
			<P>Обозначение</P>
		</TD>
		<TD>
			<P>Описание</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8A00</P>
		</TD>
		<TD>
			<P>L_CONTROL_TABLE_PLX</P>
		</TD>
		<TD>
			<P>Управляющая таблица содержащая логические номера каналов (до
			96). В соответствии с ней DSP производит последовательный
			циклический сбор данных с АЦП. Размер этой таблицы задается
			переменной L_CONTROL_TABLE_LENGTH_PLX. По умолчанию { 0, 1, 2, 3,
			4, 5, 6, 7 }</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D00</P>
		</TD>
		<TD>
			<P>L_SCALE_PLX</P>
		</TD>
		<TD>
			<P>Массив с 4 калибровочными коэффициентами используемый при
			корректировке масштаба данных с АЦП. По умолчанию {7FFF, 0x7FFF,
			0x7FFF, 0x7FFF }</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D04</P>
		</TD>
		<TD>
			<P>L_ZERO_PLX</P>
		</TD>
		<TD>
			<P>Массив с 4 калибровочными коэффициентами используемый при
			корректировке смещения нуля данных с АЦП. По умолчанию { 0x0, 0x0,
			0x0, 0x0 }</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D08</P>
		</TD>
		<TD>
			<P>L_CONTROL_TABLE_LENGHT_PLX</P>
		</TD>
		<TD>
			<P>Размер управляющей таблицы. По умолчанию 8.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D40</P>
		</TD>
		<TD>
			<P>L_READY_PLX</P>
		</TD>
		<TD>
			<P>Флажок готовности платы к дальнейшей работе. После загрузки
			управляющей программы в DSP необходимо дождаться установления
			данного флажка в 1.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D41</P>
		</TD>
		<TD>
			<P>L_TMODE1_PLX</P>
		</TD>
		<TD>
			<P>Тестовая переменная. После загрузки управляющей программы по
			этому адресу должно читаться число 0x5555.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D42</P>
		</TD>
		<TD>
			<P>L_TMODE2_PLX</P>
		</TD>
		<TD>
			<P>Тестовая переменная. После загрузки управляющей программы по
			этому адресу должно читаться число 0xAAAA.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D48</P>
		</TD>
		<TD>
			<P>L_DSP_TYPE_PLX</P>
		</TD>
		<TD>
			<P>Переменная, передающая драйверу тип установленного на модуле
			DSP. 0 - ADSP2184; 1 - ADSP2185; 2 - ADSP2186; По умолчанию 0.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D49</P>
		</TD>
		<TD>
			<P>L_COMMAND_PLX</P>
		</TD>
		<TD>
			<P>Переменная, при помощи которой драйверу передается номер
			команды.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D4C</P>
		</TD>
		<TD>
			<P>L_TTL_OUT_PLX</P>
		</TD>
		<TD>
			<P>Переменная, в которой хранятся значения 16-ти выходных цифровых
			линий.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D4D</P>
		</TD>
		<TD>
			<P>L_TTL_IN_PLX</P>
		</TD>
		<TD>
			<P>Переменная, в которой хранятся значения 16-ти входных цифровых
			линий.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D50</P>
		</TD>
		<TD>
			<P>L_FIFO_PTR_PLX</P>
		</TD>
		<TD>
			<P>Переменная, в которой хранится текущий адрес заполнения
			кольцевого буфера. Данная переменная по мере ввода данных меняет
			свое значение от L_ADC_FIFO_BASE_ADDRESS_PLX до
			L_ADC_FIFO_ADDRESS_PLX + L_ADC_FIFO_LENGTH_PLX.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D52</P>
		</TD>
		<TD>
			<P>L_TEST_LOAD_PLX</P>
		</TD>
		<TD>
			<P>Тестовая переменная.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D53</P>
		</TD>
		<TD>
			<P>L_ADC_RATE_PLX</P>
		</TD>
		<TD>
			<P>Переменная, задающая частоту работы АЦП.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D54</P>
		</TD>
		<TD>
			<P>L_INTER_KADR_DELAY_PLX</P>
		</TD>
		<TD>
			<P>Переменная, задающая межкадровую задержку при вводе данных с
			АЦП.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D55</P>
		</TD>
		<TD>
			<P>L_DAC_RATE_PLX</P>
		</TD>
		<TD>
			<P>Переменная, задающая частоту вывода данных с ЦАП-ов.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D56</P>
		</TD>
		<TD>
			<P>L_DAC_VALUE_PLX</P>
		</TD>
		<TD>
			<P>Величина, которую требуется установить на выходе ЦАП-а.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D57</P>
		</TD>
		<TD>
			<P>L_ENABLE_IRQ_PLX</P>
		</TD>
		<TD>
			<P>Запрещение(0)/разрешение(1) генерации прерывания в PC при
			соответствующем заполнении кольцевого буфера АЦП. По умолчанию -
			0.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D58</P>
		</TD>
		<TD>
			<P>L_IRQ_STEP_PLX</P>
		</TD>
		<TD>
			<P>Переменная, задающая число отсчетов при заполнении кольцевого
			буфера АЦП, каждый раз при превышении которого генерируется
			прерывание в PC</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D5A</P>
		</TD>
		<TD>
			<P>L_IRQ_FIFO_ADDRESS_PLX</P>
		</TD>
		<TD>
			<P>Если произошло прерывание в PC, то начиная с этого адреса можно
			считать L_IRQ_STEP_PLX отсчетов из кольцевого буфера АЦП.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D5B</P>
		</TD>
		<TD>
			<P>L_ENABLE_IRQ_VALUE_PLX</P>
		</TD>
		<TD>
			<P>Переменная, значение которой при выполнении соответствующей
			команды передается в переменную L_ENABLE_IRQ_PLX.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D5C</P>
		</TD>
		<TD>
			<P>L_ADC_SAMPLE_PLX</P>
		</TD>
		<TD>
			<P>Данная переменная используется при однократном вводе с АЦП,
			храня считанное значение.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D5D</P>
		</TD>
		<TD>
			<P>L_ADC_CHANNEL_PLX</P>
		</TD>
		<TD>
			<P>Данная переменная используется при однократном вводе с АЦП,
			задавая логический номер канала.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D5E</P>
		</TD>
		<TD>
			<P>L_DAC_SCLK_DIV_PLX</P>
		</TD>
		<TD>
			<P>-</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D60</P>
		</TD>
		<TD>
			<P>L_CORRECTION_ENABLE_PLX</P>
		</TD>
		<TD>
			<P>Разрешение(1)/запрещение(0) корректировки данных аналоговых
			каналов при помощи калибровочных коэффициентов. По умолчанию - 0.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D62</P>
		</TD>
		<TD>
			<P>L_ADC_ENABLE_PLX</P>
		</TD>
		<TD>
			<P>Запрещение(0)/разрешение(1) работы АЦП.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D63</P>
		</TD>
		<TD>
			<P>L_ADC_FIFO_BASE_ADDRESS_PLX</P>
		</TD>
		<TD>
			<P>Текущий базовый адрес кольцевого буфера АЦП. По умолчанию -
			0x2000.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D64</P>
		</TD>
		<TD>
			<P>L_ADC_FIFO_BASE_ADDRESS_INDEX_PLX</P>
		</TD>
		<TD>
			<P>Переменная, задающая базовый адрес кольцевого буфера АЦП. Может
			принимать три значения:0 - (0x0000 для ADSP-2185),1 - (0x2000 для
			ADSP-2185 -2186), 2 - (0x3000 для ADSP-2185 -2186; 0x2000 для
			ADSP-2184).</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D65</P>
		</TD>
		<TD>
			<P>L_ADC_FIFO_LENGTH_PLX</P>
		</TD>
		<TD>
			<P>Текущая длина кольцевого буфера АЦП. По умолчанию 0x800.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D66</P>
		</TD>
		<TD>
			<P>L_ADC_NEW_FIFO_LENGTH_PLX</P>
		</TD>
		<TD>
			<P>Переменная, задающая длину кольцевого буфера АЦП.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D67</P>
		</TD>
		<TD>
			<P>L_DAC_ENABLE_STREAM_PLX</P>
		</TD>
		<TD>
			<P>Запрещение(0)/разрешение(1) вывода данных из буфера ЦАП на ЦАП.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D68</P>
		</TD>
		<TD>
			<P>L_DAC_FIFO_BASE_ADDRESS_PLX</P>
		</TD>
		<TD>
			<P>Текущий базовый адрес буфера ЦАП. Данный буфер расположен в
			памяти программ DSP. По умолчанию 0xC00.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D69</P>
		</TD>
		<TD>
			<P>L_DAC_FIFO_LENGTH_PLX</P>
		</TD>
		<TD>
			<P>Текущая длина буфера ЦАП. По умолчанию 0x400.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D6A</P>
		</TD>
		<TD>
			<P>L_DAC_NEW_FIFO_LENGTH_PLX</P>
		</TD>
		<TD>
			<P>Переменная, задающая длину буфера ЦАП.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D70</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_TYPE_PLX</P>
		</TD>
		<TD>
			<P>Переменная, задающая тип синхронизации.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D73</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_AD_CHANNEL_PLX</P>
		</TD>
		<TD>
			<P>При аналоговой синхронизации задает логический номер канала, по
			которому происходит синхронизация.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D74</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_AD_POROG_PLX</P>
		</TD>
		<TD>
			<P>Порог аналоговой синхронизации.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D75</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_AD_MODE_PLX</P>
		</TD>
		<TD>
			<P>Переменная, задающая режим синхронизации по переходу &quot;снизу
			- вверх&quot;(0) или &quot;сверху - вниз&quot;(1)</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D76</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_AD_SENSITIVITY_PLX</P>
		</TD>
		<TD>
			<P>Переменная, задающая тип синхронизации по уровню(0) или по
			переходу(1).</P>
		</TD>
	</TR>
</TABLE>
<P><BR><BR>
</P>

<br clear=all style='page-break-before:always'>
<H3>Адресное пр-во и команды биос L-1221</H3>

<P>Адресное пространство L-1221. 
</P>
<TABLE COLS=3 WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P>Адрес</P>
		</TD>
		<TD>
			<P>Чтение</P>
		</TD>
		<TD>
			<P>Запись</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+0</P>
		</TD>
		<TD>
			<P>16-битные данные передаваемые по каналу IDMA. 
			</P>
		</TD>
		<TD>
			<P>16-битные данные передаваемые по каналу IDMA. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+2</P>
		</TD>
		<TD>
			<P>Вызывает генерацию прерывания IRQ1 в сигнальном процессоре.
			Служит для генерации команды. 
			</P>
		</TD>
		<TD>
			<P>Устанавливает начальный адрес IDMA . Данные
			передаваемые/считываемые в/из DSP будут размещаться/считываться
			начиная с этого адреса. 
			</P>
		</TD>
	</TR>
</TABLE>
<P>Список команд поддерживаемых биос L-1221 
</P>
<TABLE COLS=4 WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P>Номер</P>
		</TD>
		<TD>
			<P>Обозначение</P>
		</TD>
		<TD>
			<P>Описание</P>
		</TD>
		<TD>
			<P>Использует</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0</P>
		</TD>
		<TD>
			<P>cmTEST_1221</P>
		</TD>
		<TD>
			<P>Проверка загрузки платы и ее работоспособности;</P>
		</TD>
		<TD>
			<P>L_TEST_LOAD_1221</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>1</P>
		</TD>
		<TD>
			<P>cmFLASH_WRITE_1221</P>
		</TD>
		<TD>
			<P>Запись байта в ППЗУ. {зарезервирована}</P>
		</TD>
		<TD>
			<P>-</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>2</P>
		</TD>
		<TD>
			<P>cmFLASH_READ_1221</P>
		</TD>
		<TD>
			<P>Чтение байта из ППЗУ.</P>
		</TD>
		<TD>
			<P>L_FLASH_ADDRESS_1221, L_FLASH_BYTE_1221</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>3</P>
		</TD>
		<TD>
			<P>cmSET_TTL_1221</P>
		</TD>
		<TD>
			<P>Установка цифровых линий.</P>
		</TD>
		<TD>
			<P>L_TTL_CONFIG_1221, L_TTL_OUT_1221</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>4</P>
		</TD>
		<TD>
			<P>cmGET_TTL_1221</P>
		</TD>
		<TD>
			<P>Чтение цифровых линий.</P>
		</TD>
		<TD>
			<P>L_TTL_CONFIG_1221, L_TTL_IN_1221</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>5</P>
		</TD>
		<TD>
			<P>cmENABLE_IRQ_1221</P>
		</TD>
		<TD>
			<P>Разрешение/запрещение прерываний.</P>
		</TD>
		<TD>
			<P>L_ENABLE_IRQ_1221</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>6</P>
		</TD>
		<TD>
			<P>cmRESET_AD_1221</P>
		</TD>
		<TD>
			<P>Переинициализация аналогового тракта.</P>
		</TD>
		<TD>
			<P>L_CHANNEL_MASK_1221, L_RATE_SCALE_1221, L_READY_1221</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>7</P>
		</TD>
		<TD>
			<P>cmSET_GAIN_1221</P>
		</TD>
		<TD>
			<P>Установка входного диапазона.</P>
		</TD>
		<TD>
			<P>L_GAIN_CHANNEL_1221, L_GAIN_1221</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>8</P>
		</TD>
		<TD>
			<P>cmSET_RATE_1221</P>
		</TD>
		<TD>
			<P>Установка частоты ввода.</P>
		</TD>
		<TD>
			<P>L_GAIN_1221</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>9</P>
		</TD>
		<TD>
			<P>cmCONFIG_FIFO_1221</P>
		</TD>
		<TD>
			<P>Установка параметров буфера.</P>
		</TD>
		<TD>
			<P>L_FIFO_START_ADDRESS_1221, L_FIFO_LENGTH_1221</P>
		</TD>
	</TR>
</TABLE>
<P>Список внутренних переменных биос L-1221 
</P>
<TABLE COLS=3 WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P>Адрес</P>
		</TD>
		<TD>
			<P>Обозначение</P>
		</TD>
		<TD>
			<P>Описание</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x2000</P>
		</TD>
		<TD>
			<P>L_BUFFER_1221</P>
		</TD>
		<TD>
			<P>По умолчанию базовый адрес буфера в плате L-1221, размером 4096
			слов. Данный адрес используется при чтении данных, поступающих с
			аналоговых каналов. Если были сделаны переустановки параметров
			буфера с помощью команды cmCONFIG_FIFO_1221, то надо пользоваться
			переменными L_FIFO_START_ADDRESS_1221 и L_FIFO_LENGTH.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3C80</P>
		</TD>
		<TD>
			<P>L_SCALE_1221</P>
		</TD>
		<TD>
			<P>Массив с 64 калибровочными коэффициентами масштаба аналоговых
			каналов.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3CC0</P>
		</TD>
		<TD>
			<P>L_ZERO_1221</P>
		</TD>
		<TD>
			<P>Массив с 64 калибровочными коэффициентами смещения нуля в
			режиме измерения постоянного напряжения.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D00</P>
		</TD>
		<TD>
			<P>L_ZERO_FLT_1221</P>
		</TD>
		<TD>
			<P>Массив с 64 калибровочными коэффициентами смещения нуля в
			режиме фильтрации постоянной составляющей.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D40</P>
		</TD>
		<TD>
			<P>L_KADR_1221</P>
		</TD>
		<TD>
			<P>Массив из 8 чисел с последними данными со всех восьми
			аналоговых каналов платы. Независимо от переменной
			L_CHANNEL_MASK_1221 в массив L_KADR_1221 постоянно подгружаются
			данные со всех аналоговых каналов. При этом по адресу L_KADR_1221
			будет считываться код с первого канала АЦП, а по адресу
			L_KADR_1221+7 - с восьмого канала.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D48</P>
		</TD>
		<TD>
			<P>L_TMODE_1221</P>
		</TD>
		<TD>
			<P>Тестовая переменная, после загрузки управляющей программы по
			этому адресу должно читаться число 5.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D49</P>
		</TD>
		<TD>
			<P>L_COMMAND_1221</P>
		</TD>
		<TD>
			<P>Переменная, при помощи которой задается номер команды.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D4A</P>
		</TD>
		<TD>
			<P>L_FLASH_ADDRESS_1221</P>
		</TD>
		<TD>
			<P>Адрес байта в ППЗУ. ППЗУ - энергонезависимая память на плате, в
			которой хранятся калибровочные коэффициенты.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D4B</P>
		</TD>
		<TD>
			<P>L_FLASH_BYTE_1221</P>
		</TD>
		<TD>
			<P>Байт данных записываемый/считываемый в/из ППЗУ.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D4C</P>
		</TD>
		<TD>
			<P>L_TTL_OUT_1221</P>
		</TD>
		<TD>
			<P>Слово, в котором хранятся значения 3 выходных цифровых линий.
			Формат - 00000000 0ХХХ000Y.Y - управляет режимом отсечки.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D4D</P>
		</TD>
		<TD>
			<P>L_TTL_IN_1221</P>
		</TD>
		<TD>
			<P>Слово, в котором хранятся значения 3 входных цифровых линий.
			Формат - 00000000 0ХХХ0000.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D4E</P>
		</TD>
		<TD>
			<P>L_OVERFLOW_1221</P>
		</TD>
		<TD>
			<P>Слово, в котором запоминаются биты, фиксирующие переполнение на
			аналоговых каналах. 1 - переполнение. Младший бит соответствует 0
			каналу, старший - 7. Формат - 00000000 ХХХХХХХХ</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D4F</P>
		</TD>
		<TD>
			<P>L_ENABLE_IRQ_1221</P>
		</TD>
		<TD>
			<P>Слово, разрешающее(1)/запрещающее(0) генерирование прерываний
			от платы к компьютеру.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D50</P>
		</TD>
		<TD>
			<P>L_FIFO_PTR_1221</P>
		</TD>
		<TD>
			<P>Переменная , в которой хранится текущий адрес заполнения
			буфера. Данная переменная по мере ввода данных меняет свое
			значение от L_FIFO_START_ADDRESS_1221 до L_FIFO_START_ADDRESS_1221
			+ L_FIFO_LENGTH_1221-1.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D51</P>
		</TD>
		<TD>
			<P>L_CHANNEL_MASK_1221</P>
		</TD>
		<TD>
			<P>Битовая маска, при помощи которой задаются активные каналы,
			т.е. те каналы АЦП, данные с которых надо помещать в буфер. Формат
			- 00000000 ХХХХХХХХ.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D52</P>
		</TD>
		<TD>
			<P>L_TEST_LOAD_1221</P>
		</TD>
		<TD>
			<P>Тестовая переменная. 0xAA55.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D53</P>
		</TD>
		<TD>
			<P>L_RATE_1221</P>
		</TD>
		<TD>
			<P>Переменная устанавливающая частоту ввода данных. Целое число от
			0 до 14 :0-6.99 kHz,1-7.46 kHz,2-7.99 kHz,3-8.6 kHz,4-9.32
			kHz,5-10.17 kHz,6-11.19 kHz,7-12.43 kHz,8-13.98 kHz,9-15.98
			kHz,10-18.64 kHz,11-22.37 kHz,12-27.97 kHz,13-37.29 kHz,14-55.93
			kHz.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D54</P>
		</TD>
		<TD>
			<P>L_RATE_SCALE_1221</P>
		</TD>
		<TD>
			<P>Масштаб частоты ввода. Уменьшает частоту ввода :
			0-1,1-16,2-256,3-4096.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D55</P>
		</TD>
		<TD>
			<P>L_GAIN_CHANNEL_1221</P>
		</TD>
		<TD>
			<P>Номер канала на котором изменяется входной диапазон.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D56</P>
		</TD>
		<TD>
			<P>L_GAIN_1221</P>
		</TD>
		<TD>
			<P>Устанавливаемый входной диапазон : 0-6.3 В,1-3.15 В,2-1.5
			В,3-0.75 В,4-0.375 В,5-0.18 В,6-0.08 В,7-0.04 В.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D57</P>
		</TD>
		<TD>
			<P>L_IRQ_STEP_1221</P>
		</TD>
		<TD>
			<P>Шаг, с которым генерируется прерывание по мере заполнения
			буфера.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D58</P>
		</TD>
		<TD>
			<P>L_N_BIT_1221</P>
		</TD>
		<TD>
			<P>Разрядность АЦП. Фактически сдвиг данных в право. 16 бит - (0)
			15 бит - (-1) ...</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D59</P>
		</TD>
		<TD>
			<P>L_FIFO_N_LOW_1221</P>
		</TD>
		<TD>
			<P>Младшее слово числа введенных частей буфера.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D5A</P>
		</TD>
		<TD>
			<P>L_FIFO_N_HIGH_1221</P>
		</TD>
		<TD>
			<P>Старшее слово числа введенных частей буфера.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D5B</P>
		</TD>
		<TD>
			<P>L_IRQ0_N_LOW_1221</P>
		</TD>
		<TD>
			<P>Младшее слово счетчика внешних импульсов.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D5C</P>
		</TD>
		<TD>
			<P>L_IRQ0_N_HIGH_1221</P>
		</TD>
		<TD>
			<P>Старшее слово счетчика внешних импульсов.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D5D</P>
		</TD>
		<TD>
			<P>L_TTL_CONFIG_1221</P>
		</TD>
		<TD>
			<P>Конфигурация TTL линий. 1 - выход 0 &ndash; вход. Формат -
			00000000 0ХХХ0000</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D63</P>
		</TD>
		<TD>
			<P>L_CORRECTION_ENABLE_1221</P>
		</TD>
		<TD>
			<P>Переменная запрещающая(0)/разрешающая(1) коррекцию вводимых
			данных. По умолчанию - 0;</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D64</P>
		</TD>
		<TD>
			<P>L_FIFO_START_ADDRESS_1221</P>
		</TD>
		<TD>
			<P>Переменная, задающая начальный адрес буфера. Если она равна
			нулю, то адрес равен 0х0000. Если не равна нулю - адрес равен
			0х2000. По умолчанию - 0х2000.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D65</P>
		</TD>
		<TD>
			<P>L_FIFO_LENGTH_1221</P>
		</TD>
		<TD>
			<P>Определяет длину буфера. По умолчанию 0х1000.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D69</P>
		</TD>
		<TD>
			<P>L_READY_1221</P>
		</TD>
		<TD>
			<P>0 - do calibration 1 &ndash; ready. Переменная сигнализирующая
			о готовности платы.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D70</P>
		</TD>
		<TD>
			<P>L_IRQ_ADDRESS_1221</P>
		</TD>
		<TD>
			<P>Переменная указывающая на каком адресе в буфере произошло
			прерывание.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3F6C</P>
		</TD>
		<TD>
			<P>L_TEMPERATURE_1221</P>
		</TD>
		<TD>
			<P>Температура платы.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D5E</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_TYPE_1221</P>
		</TD>
		<TD>
			<P>Переменная, задающая тип синхронизации.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D5F</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_AD_CHANNEL_1221</P>
		</TD>
		<TD>
			<P>При аналоговой синхронизации задает номер канала, по которому
			происходит синхронизация.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D60</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_AD_POROG_1221</P>
		</TD>
		<TD>
			<P>Порог аналоговой синхронизации.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D61</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_AD_MODE_1221</P>
		</TD>
		<TD>
			<P>Переменная, задающая режим синхронизации по переходу &quot;снизу
			- вверх&quot;(0) или &quot;сверху - вниз&quot;(1)</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x3D62</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_AD_SENSITIVITY_1221</P>
		</TD>
		<TD>
			<P>Переменная, задающая тип синхронизации по уровню(0) или по
			переходу(1).</P>
		</TD>
	</TR>
</TABLE>
<P><BR><BR>
</P>

<br clear=all style='page-break-before:always'>
<H3>Адресное пр-во и команды биос L-1450</H3>

<P>Адресное пространство L-1450. 
</P>
<TABLE COLS=3 WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P>Адрес</P>
		</TD>
		<TD>
			<P>Чтение</P>
		</TD>
		<TD>
			<P>Запись</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+0x0</P>
		</TD>
		<TD>
			<P>Порт данных. Чтение 16-битного слова из порта данных. Все 16
			считываемых бит являются значимыми. До тех пор, пока процессор DSP
			ничего не записал в порт данных, соответствующий бит готовности
			равен нулю. После записи 16-битного слова в порт данных сигнальным
			процессором автоматически устанавливается в единичное значение бит
			готовности RDYR, который переключится в ноль после того, как
			компьютер считает переданное слово. 
			</P>
		</TD>
		<TD>
			<P>Порт данных. Запись 16-битного слова в порт данных. Все 16
			записываемых бит являются значимыми. После записи слова в порт
			данных автоматически устанавливается в нулевое значение бит
			готовности RDYW, который переключится в единицу автоматически
			после того, как процессор ADSP считает переданное слово. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+0x4</P>
		</TD>
		<TD>
			<P>Порт дополнительных данных. Имеют значение только два младших
			бита в принимаемых данных, которые используются в штатном LBIOS
			при работе с платой по прерываниям. 
			</P>
		</TD>
		<TD>
			<P>Порт EIORDY. Разрешения использования сигнала I/O CH RDY
			магистрали ISA. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+0x8</P>
		</TD>
		<TD>
			<P>Порт сброса запроса прерывания. В том случае если используется
			прерывание IRQ 10/11/12/15, то обработчик данного прерывания в РС
			обязан произвести одно чтение из описываемого порта для сброса
			запроса прерывания. В противном случае линия прерываний окажется
			заблокированной. 
			</P>
		</TD>
		<TD>
			<P>Порт команд. При записи номера команды в данный порт
			автоматически генерируется прерывание IRQ2 в сигнальном процессоре
			и, одновременно с этим, записывает передаваемое число в порт
			данных. При этом обработчик прерывания драйвера LBIOS в ответ на
			запрос IRQ2 считывает переданный номер команды и вызывает
			процедуру, соответствующую переданному номеру команд. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Base+0xC</P>
		</TD>
		<TD>
			<P>Порт статуса. Порт битов готовности записи RDYW и чтения RDYR. 
			</P>
		</TD>
		<TD>
			<P>Порт управления. При помощи порта конфигурации можно:загрузить
			в процессор управляющую программу,отключить линию прерывания IRQ
			10/11/12/15,перевести плату в режим работы по каналам Прямого
			Доступа к Памяти (ПДП). 
			</P>
		</TD>
	</TR>
</TABLE>
<P>Список команд поддерживаемых биос L-1450 
</P>
<TABLE COLS=4 WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P>Номер</P>
		</TD>
		<TD>
			<P>Обозначение</P>
		</TD>
		<TD>
			<P>Описание</P>
		</TD>
		<TD>
			<P>Использует</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0</P>
		</TD>
		<TD>
			<P>cmTEST_L1450</P>
		</TD>
		<TD>
			<P>Проверка загрузки платы и ее работоспособности.</P>
		</TD>
		<TD>
			<P>L_TEST_LOAD_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>1</P>
		</TD>
		<TD>
			<P>cmGET_DM_WORD_L1450</P>
		</TD>
		<TD>
			<P>Чтение слова из памяти данных DSP</P>
		</TD>
		<TD>
			<P>-</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>2</P>
		</TD>
		<TD>
			<P>cmPUT_DM_WORD_L1450</P>
		</TD>
		<TD>
			<P>Запись слова в память данных DSP</P>
		</TD>
		<TD>
			<P>-</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>3</P>
		</TD>
		<TD>
			<P>cmGET_PM_WORD_L1450</P>
		</TD>
		<TD>
			<P>Чтение слова из памяти программ DSP</P>
		</TD>
		<TD>
			<P>-</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>4</P>
		</TD>
		<TD>
			<P>cmPUT_PM_WORD_L1450</P>
		</TD>
		<TD>
			<P>Запись слова в память программ DSP</P>
		</TD>
		<TD>
			<P>-</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>5</P>
		</TD>
		<TD>
			<P>cmGET_DM_ARRAY_L1450</P>
		</TD>
		<TD>
			<P>Чтение массива слов из памяти данных DSP</P>
		</TD>
		<TD>
			<P>-</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>6</P>
		</TD>
		<TD>
			<P>cmPUT_DM_ARRAY_L1450</P>
		</TD>
		<TD>
			<P>Запись массива слов в память данных DSP</P>
		</TD>
		<TD>
			<P>-</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>7</P>
		</TD>
		<TD>
			<P>cmGET_PM_ARRAY_L1450</P>
		</TD>
		<TD>
			<P>Чтение массива слов из памяти программ DSP</P>
		</TD>
		<TD>
			<P>-</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>8</P>
		</TD>
		<TD>
			<P>cmPUT_PM_ARRAY_L1450</P>
		</TD>
		<TD>
			<P>Запись массива слов в память программ DSP</P>
		</TD>
		<TD>
			<P>-</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>9</P>
		</TD>
		<TD>
			<P>cmENABLE_FLASH_WRITE_L1450</P>
		</TD>
		<TD>
			<P>Разрешение процедуры записи в пользовательское ППЗУ</P>
		</TD>
		<TD>
			<P>L_FLASH_ENABLE_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>10</P>
		</TD>
		<TD>
			<P>cmREAD_FLASH_WORD_L1450</P>
		</TD>
		<TD>
			<P>Чтение слова из ППЗУ</P>
		</TD>
		<TD>
			<P>L_FLASH_ADDRESS_L1450, L_FLASH_DATA_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>11</P>
		</TD>
		<TD>
			<P>cmWRITE_FLASH_WORD_L1450</P>
		</TD>
		<TD>
			<P>Запись слова в ППЗУ</P>
		</TD>
		<TD>
			<P>L_FLASH_ADDRESS_L1450, L_FLASH_DATA_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>12</P>
		</TD>
		<TD>
			<P>cmSTART_L1450</P>
		</TD>
		<TD>
			<P>Разрешение работы АЦП и/или ЦАП</P>
		</TD>
		<TD>
			<P>L_ADC_ENABLE_L1450, L_ENA_ADC_IRQ_L1450, L_ADC_DATA_STEP_L1450,
			L_DAC_ENABLE_L1450, L_ENA_DAC_IRQ_L1450, L_DAC_DATA_STEP_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>13</P>
		</TD>
		<TD>
			<P>cmSET_ADC_PARS_L1450</P>
		</TD>
		<TD>
			<P>Установка параметров работы АЦП</P>
		</TD>
		<TD>
			<P>L_CONTROL_TABLE_L1450, L_CONTROL_TABLE_LENGHT_L1450,
			L_ADC_RATE_L1450, L_INTER_KADR_SCALE_L1450,
			L_INTER_KADR_PERIOD_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>14</P>
		</TD>
		<TD>
			<P>cmADC_FIFO_CONFIG_L1450</P>
		</TD>
		<TD>
			<P>Конфигурирование параметров FIFO буфера АЦП.</P>
		</TD>
		<TD>
			<P>L_ADC_FIFO_BASE_ADDRESS_L1450, L_ADC_FIFO_BASE_ADDRESS_INDEX_
			L1450, L_ADC_FIFO_LENGTH_L1450, L_ADC_NEW_FIFO_LENGTH_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>15</P>
		</TD>
		<TD>
			<P>cmADC_SAMPLE_L1450</P>
		</TD>
		<TD>
			<P>Однократный ввод отсчета АЦП с заданного канала</P>
		</TD>
		<TD>
			<P>L_ADC_SAMPLE_L1450, L_ADC_CHANNEL_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>16</P>
		</TD>
		<TD>
			<P>cmSYNCHRO_CONFIG_L1450</P>
		</TD>
		<TD>
			<P>Управление синхронизацией начала ввода данных с АЦП.</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_TYPE_L1450, L_SYNCHRO_AD_CHANNEL_L1450,
			L_SYNCHRO_AD_POROG_L1450, L_SYNCHRO_AD_MODE_L1450,
			L_SYNCHRO_AD_SENSITIVITY_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>17</P>
		</TD>
		<TD>
			<P>cmDAC_FIFO_CONFIG_L1450</P>
		</TD>
		<TD>
			<P>Конфигурирование пара-метров FIFO буфера ЦАП.</P>
		</TD>
		<TD>
			<P>L_DAC_FIFO_BASE_ADDRESS_L1450, L_DAC_FIFO_LENGTH_L1450,
			L_DAC_NEW_FIFO_LENGTH_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>18</P>
		</TD>
		<TD>
			<P>cmSET_DAC_RATE_L1450</P>
		</TD>
		<TD>
			<P>Установка частоты вывода данных из FIFO буфера ЦАП</P>
		</TD>
		<TD>
			<P>L_DAC_RATE_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>19</P>
		</TD>
		<TD>
			<P>cmENABLE_TTL_OUT_L1450</P>
		</TD>
		<TD>
			<P>Разрешение выходных цифровых линий</P>
		</TD>
		<TD>
			<P>L_ENABLE_TTL_OUT_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>20</P>
		</TD>
		<TD>
			<P>cmTTL_IN_L1450</P>
		</TD>
		<TD>
			<P>Считывание состояния 16ти внешних цифровых линий.</P>
		</TD>
		<TD>
			<P>L_TTL_IN_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>21</P>
		</TD>
		<TD>
			<P>cmTTL_OUT_L1450</P>
		</TD>
		<TD>
			<P>Управление 16тью внешними цифровыми линиями.</P>
		</TD>
		<TD>
			<P>L_TTL_OUT_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>22</P>
		</TD>
		<TD>
			<P>cmIRQ_TEST_L1450</P>
		</TD>
		<TD>
			<P>Тестовая функция для генерирования прерываний в РС с частотой
			примерно 300 Гц.</P>
		</TD>
		<TD>
			<P>L_ENABLE_IRQ_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>23</P>
		</TD>
		<TD>
			<P>cmSET_PAGE_MEMORY_L1450</P>
		</TD>
		<TD>
			<P>Установка номера страницы внешней памяти</P>
		</TD>
		<TD>
			<P>L_PAGE_MEMORY_L1450</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>24</P>
		</TD>
		<TD>
			<P>cmSET_DSP_TYPE_L1450</P>
		</TD>
		<TD>
			<P>Передает в драйвер LBIOS тип установленного на плате DSP и
			соответствующим образом модифицирует код драйвера.</P>
		</TD>
		<TD>
			<P>L_DSP_TYPE_L1450</P>
		</TD>
	</TR>
</TABLE>
<P>Список внутренних переменных биос L-1450 (8 - признак того, что
это DM) 
</P>
<TABLE COLS=3 WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P>Адрес</P>
		</TD>
		<TD>
			<P>Обозначение</P>
		</TD>
		<TD>
			<P>Описание</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8A00</P>
		</TD>
		<TD>
			<P>L_CONTROL_TABLE_L1450</P>
		</TD>
		<TD>
			<P>Управляющая таблица, содержащая последовательность логических
			номеров каналов (максимум 128 элементов). В соответствии с ней DSP
			производит последовательный циклический сбор данных с АЦП. Размер
			этой таблицы задается переменной L_CONTROL_TABLE_LENGHT_ L1450
			(см. ниже). По умолчанию - { 0, 1, 2, 3, 4, 5, 6, 7}</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D00</P>
		</TD>
		<TD>
			<P>L_SCALE_L1450</P>
		</TD>
		<TD>
			<P>Массив с 4 калибровочными коэффициентами, используемый при
			корректировки масштаба данных с АЦП. По умолчанию - { 0x7FFF,
			0x7FFF, 0x7FFF, 0x7FFF}</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D04</P>
		</TD>
		<TD>
			<P>L_ZERO_L1450</P>
		</TD>
		<TD>
			<P>Массив с 4 калибровочными коэффициентами, используемый при
			корректировки смещения нуля данных с АЦП. По умолчанию - { 0x0,
			0x0, 0x0, 0x0}</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D08</P>
		</TD>
		<TD>
			<P>L_CONTROL_TABLE_LENGHT_PLX</P>
		</TD>
		<TD>
			<P>Размер управляющей таблицы (максимум 128 логических каналов).
			По умолчанию - 8.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D0A</P>
		</TD>
		<TD>
			<P>L_IS_EXT_MEM_EXIST_L1450</P>
		</TD>
		<TD>
			<P>Флажок наличия внешней памяти данных</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D0B</P>
		</TD>
		<TD>
			<P>L_PAGE_MEMORY_L1450</P>
		</TD>
		<TD>
			<P>Текущий номер используемой страницы внешней памяти (только для
			плат Rev.'A')</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D41</P>
		</TD>
		<TD>
			<P>L_TMODE1_L1450</P>
		</TD>
		<TD>
			<P>Тестовая переменная. После загрузки драйвера (LBIOS) по этому
			адресу должно читаться число 0x5555.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D42</P>
		</TD>
		<TD>
			<P>L_TMODE2_L1450</P>
		</TD>
		<TD>
			<P>Тестовая переменная. После загрузки драйвера (LBIOS) по этому
			адресу должно читаться число 0xAAAA.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D43</P>
		</TD>
		<TD>
			<P>L_ENA-DAC_IRQ_L1450</P>
		</TD>
		<TD>
			<P>Данная переменная разрешает (0х1) либо запрещает (0х0)
			генерирование прерываний в PC по мере необходимости новых данных
			для FIFO буфера ЦАП. По умолчанию - 0х0.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D48</P>
		</TD>
		<TD>
			<P>L_DSP_TYPE_L1450</P>
		</TD>
		<TD>
			<P>Переменная, передающая драйверу (LBIOS) тип установленного на
			модуле DSP. Если она равна 0, то на плате установлен ADSP-2184 (4
			КСлов памяти программ и 4 КСлов памяти данных). Если она равна 1,
			то - ADSP-2185 (16 кСлов памяти программ и 16 КСлов памяти
			данных). Если она равна 2, то - ADSP-2186 (8 КСлов памяти программ
			и 8 КСлов памяти данных). По умолчанию L_DSP_TYPE_L1450=0.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D4B</P>
		</TD>
		<TD>
			<P>L_DAC_DATA_STEP_L1450</P>
		</TD>
		<TD>
			<P>Переменная, задающая шаг (число отсчетов) при генерировании
			прерываний в РС по мере необходимости в получении новых данных для
			FIFO буфера ЦАП. При помощи этой перемен-ной можно сделать так,
			что прерывания в РС будут генерироваться, например, после каждых
			20 отсчетов выведенных на ЦАП. По умолчанию - 0х200.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D4C</P>
		</TD>
		<TD>
			<P>L_TTL_OUT_L1450</P>
		</TD>
		<TD>
			<P>Слово (16 бит) , в котором по-битово хранятся значения 16ти
			выходных цифровых линий для их выставления по команде
			C_TTL_OUT_L1450.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D4D</P>
		</TD>
		<TD>
			<P>L_TTL_IN_L1450</P>
		</TD>
		<TD>
			<P>Слово (16 бит), в котором после выполнения команды
			C_TTL_IN_L1450 по-битово хранятся значения 16ти входных цифровых
			линий.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D4E</P>
		</TD>
		<TD>
			<P>L_ENABLE_TTL_OUT_L1450</P>
		</TD>
		<TD>
			<P>Данная переменная разрешает (0х1) либо запрещает (0х0)
			использование выходных цифровых линий (перевод их в третье
			состояние)</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D53</P>
		</TD>
		<TD>
			<P>L_ADC_RATE_L1450</P>
		</TD>
		<TD>
			<P>Переменная, задающая частоту работы АЦП.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D54</P>
		</TD>
		<TD>
			<P>L_INTER_KADR_SCALE_L1450</P>
		</TD>
		<TD>
			<P>Переменная, совместно с L_INTER_KADR_ PERIOD_L1450 задающая
			межкадровую задержку при вводе данных с АЦП. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D55</P>
		</TD>
		<TD>
			<P>L_DAC_RATE_L1450</P>
		</TD>
		<TD>
			<P>Переменная, задающая частоту вывода данных с ЦАП-ов.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D57</P>
		</TD>
		<TD>
			<P>L_ENA_ADC_IRQ_L1450</P>
		</TD>
		<TD>
			<P>Данная переменная разрешает (0х1) либо запрещает (0х0)
			генерирование прерываний в PC по мере заполнения FIFO буфера АЦП.
			По умолчанию - 0х0.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D58</P>
		</TD>
		<TD>
			<P>L_ADC_DATA_STEP_L1450</P>
		</TD>
		<TD>
			<P>Переменная, задающая шаг (число отсчетов) при генерировании
			прерываний в РС по мере заполнения FIFO буфера АЦП. При помощи
			этой переменной можно сделать так, что прерывания в РС будут
			генерироваться, например, через каждые 20 отсчетов. По умолчанию -
			0х400.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D5A</P>
		</TD>
		<TD>
			<P>L_INTER_KADR_PERIOD_L1450</P>
		</TD>
		<TD>
			<P>Переменная, совместно с L_INTER_KADR_SCALE_L1450 задающая
			межкадровую задержку при вводе данных с АЦП. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D5C</P>
		</TD>
		<TD>
			<P>L_ADC_SAMPLE_L1450</P>
		</TD>
		<TD>
			<P>Данная переменная используется при однократном вводе с АЦП,
			храня считанное значение.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D5D</P>
		</TD>
		<TD>
			<P>L_ADC_CHANNEL_L1450</P>
		</TD>
		<TD>
			<P>Данная переменная используется при однократном вводе с АЦП,
			задавая логический номер канала.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D60</P>
		</TD>
		<TD>
			<P>L_CORRECTION_ENABLE_L1450</P>
		</TD>
		<TD>
			<P>Переменная запрещающая (0)/ разрешающая (1) корректировку
			данных аналоговых каналов при помощи калибровочных коэффициентов.
			По умолчанию L_CORRECTION_ENABLE=0х0.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D62</P>
		</TD>
		<TD>
			<P>L_ADC_ENABLE_L1450</P>
		</TD>
		<TD>
			<P>Переменная запрещающая(0)/разрешающая (1) работу АЦП.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D63</P>
		</TD>
		<TD>
			<P>L_ADC_FIFO_BASE_ADDRESS_L1450</P>
		</TD>
		<TD>
			<P>Текущий базовый адрес FIFO буфера АЦП. По умолчанию
			L_ADC_FIFO_BASE_ADDRESS_ L1450 = 0x2000.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D64</P>
		</TD>
		<TD>
			<P>L_ADC_FIFO_BASE_ADDRESS_INDEX_L1450</P>
		</TD>
		<TD>
			<P>Переменная, задающая требуемый базовый адрес FIFO буфера АЦП.
			Может принимать три значения:0 - базовый адрес начинается с адреса
			0х0 только для ADSP-2185,1 - базовый адрес начинается с адреса
			0х2000 только для ADSP-2185 и ADSP-2186,2 - базовый адрес
			начинается с адреса 0х3000 для ADSP-2185 и ADSP-2186 и с адреса
			0х2000 для ADSP-2184. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D65</P>
		</TD>
		<TD>
			<P>L_ADC_FIFO_LENGTH_L1450</P>
		</TD>
		<TD>
			<P>Текущая длина FIFO буфера АЦП. По умолчанию
			L_ADC_FIFO_LENGTH_L1450 = 0x800.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D66</P>
		</TD>
		<TD>
			<P>L_ADC_NEW_FIFO_LENGTH_L1450</P>
		</TD>
		<TD>
			<P>Переменная, задающая требуемую длину FIFO буфера АЦП.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D67</P>
		</TD>
		<TD>
			<P>L_DAC_ENABLE_L1450</P>
		</TD>
		<TD>
			<P>Переменная запрещающая (0)/разрешающая (1) вывод данных из FIFO
			буфера ЦАП на сам ЦАП.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D68</P>
		</TD>
		<TD>
			<P>L_DAC_FIFO_BASE_ADDRESS_L1450</P>
		</TD>
		<TD>
			<P>Текущий базовый адрес FIFO буфера ЦАП. Данный буфер расположен
			в памяти программ DSP. По умолчанию L_DAC_FIFO_BASE_ ADDRESS_L1450
			= 0xС00.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D69</P>
		</TD>
		<TD>
			<P>L_DAC_FIFO_LENGTH_L1450</P>
		</TD>
		<TD>
			<P>Текущая длина FIFO буфера ЦАП. По умолчанию
			L_DAC_FIFO_LENGTH_L1450 = 0x400.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D6A</P>
		</TD>
		<TD>
			<P>L_DAC_NEW_FIFO_LENGTH_L1450</P>
		</TD>
		<TD>
			<P>Переменная, задающая требуемую длину FIFO буфера ЦАП.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D70</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_TYPE_L1450</P>
		</TD>
		<TD>
			<P>Переменная, задающая тип синхронизации.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D73</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_AD_CHANNEL_L1450</P>
		</TD>
		<TD>
			<P>При аналоговой синхронизации задает логический номер канала, по
			которому происходит синхронизация.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D74</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_AD_POROG_L1450</P>
		</TD>
		<TD>
			<P>Порог аналоговой синхронизации.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D75</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_AD_MODE_L1450</P>
		</TD>
		<TD>
			<P>Переменная, задающая режим синхронизации по переходу &quot;снизу
			- вверх&quot;(0) или &quot;сверху - вниз&quot;(1)</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0x8D76</P>
		</TD>
		<TD>
			<P>L_SYNCHRO_AD_SENSITIVITY_L1450</P>
		</TD>
		<TD>
			<P>Переменная, задающая тип синхронизации по уровню(0) или по
			переходу(1).</P>
		</TD>
	</TR>
</TABLE>
<P><BR><BR>
</P>

<br clear=all style='page-break-before:always'>
<H3>Замечания для платы L791</H3>

<P>Пояснения по работе с платой L791.</P>
<P>Это плата без сигнального процессора на борту - просто цифровой
автомат. Передачу данных осуществляет по BusMaster каналу PCI.</P>
<P>Временные параметры сбора задаются таймерами.</P>
<P>Библиотека для работы с платой имеет интерфейс аналогичный
интерфейсу других плат. Но есть некоторые особенности и ограничения:</P>
<UL>
   <LI><P>циклические буфера в компьютере всегда имеют одно и тоже
   значение 128К отсчетов (32 разрядных) для АЦП и 128К отсчетов для
   ЦАП;</P>
   <LI><P>переменная -указатель sync служит не только для чтения
   счетчиков ПДП каналов, но и для прямого доступа к 32-х битным
   регистрам платы;</P>
   <LI><P>при этом указатель sync от потока ЦАП и от потока АЦП это
   одно и тоже;</P>
   <LI><P>прерывания от платы доходят к пользователю через события. При
   этом они разрешаются битами в параметре IrqEna в структуре
   описывающей сбор данных АЦП (младшие 16 бит ) и ЦАП (старшие 16
   бит).</P>
   <LI><P>с платой можно работать и напрямую по регистрам управляя
   сбором данных, но только после команды StartLDevice надо дождаться
   появления бита ADC_En в регистре управления, после чего запретить
   сбор. Дальше можно делать что хочется. В плату уже прописаны адреса
   памяти для BusMaster каналов и установлен обработчик прерывания. Все
   что хочется можно делать до команды StopLDevice.</P>
   <LI><P>про регистры платы читайте печатную книжку;</P>
   <LI><P>про логические номера каналов читайте печатную книжку;</P>
   <LI><P>размер половины фифо буфера АЦП 1,2,4,8,16,32,64,128
   отсчетов;</P>
   <LI><P>при работе следует иметь ввиду что настройки параметров сбора
   сохраняются внутри драйвера и при старт/стоп режиме если
   запрограммировали ЦАП и АЦП то они и будут работать, а если ЦАП стал
   не нужен, то надо сделать новую установку параметров где ЦАП
   отключить.</P>
</UL>

<br clear=all style='page-break-before:always'>
<H3>Замечания для модуля E14-140/E154</H3>

<P>Пояснения по работе с модулем E14-140/E154.</P>
<P>Библиотека для работы с платой имеет интерфейс аналогичный
интерфейсу других плат. Но есть некоторые особенности и ограничения:</P>
<UL>
   <LI><P>у модуля не настраивается FIFO.</P>
   <LI><P>работа в библиотеке имитирует работу по прерываниям путем
   перепосылки запросов размером IrqStep к модулю и укладывания их в
   большой буфер.</P>
   <LI><P>максимальный размер IrqStep ограничен 64 кОтсчетов.</P>
   <LI><P>Коррекция данных выполняется пользователем.</P>
</UL>

<br clear=all style='page-break-before:always'>
<H3>Замечания для модуля E20-10</H3>

<P>Пояснения по работе с модулем E20-10.</P>
<P>Библиотека для работы с платой имеет интерфейс аналогичный
интерфейсу других плат. Но есть некоторые особенности и ограничения:</P>
<UL>
	<LI><P>у модуля не настраивается FIFO.</P>
	<LI><P>работа в библиотеке имитирует работу по прерываниям путем
	перепосылки запросов размером IrqStep к модулю и укладывания их в
	большой буфер.</P>
	<LI><P>максимальный размер IrqStep ограничен 1M Отсчетов.</P>
	<LI><P>Коррекция данных выполняется пользователем.</P>
</UL>

<br clear=all style='page-break-before:always'>
<H3>Замечания для плат L780/L783/L761</H3>

<P>Пояснения по работе с платой L780M (rev C ).</P>
<P>Эта плата поддерживает потоковый вывод данных на ЦАП. Но есть
особенности в формате данных для ЦАП.</P>
<P>Если вывод программируется как для обычной 780 платы, то формат
данных в буфере USHORT, а если для потокового вывода 780M, то данные
ULONG.</P>
<P>Пример кода:</P>
<P>USHORT data1;</P>
<P>for(int i=0;i&lt;1024;i+=2)
data1[i]=((USHORT)(1024.0*sin((2.0*(3.1415*i)/1024.0)))&amp;0xFFF)|0x0000;</P>
<P>for(int i=1;i&lt;1024;i+=2)
data1[i]=((USHORT)(1024.0*sin((2.0*(3.1415*i)/1024.0)))&amp;0xFFF)|0x1000;</P>
<P>// задается два синуса по двум каналам и из памяти DSP</P>
<P><BR><BR>
</P>
<P>или</P>
<P>ULONG data1;</P>
<P>for(int i=0;i&lt;2048;i++)
data1[i]=((USHORT)(512*sin((2.0*(3.1415*i)/1024.0)))&amp;0xFFF)|0x0000;</P>
<P>// по 0 каналу синус и из буфера PC 
</P>
<P>Такая корявость получилась из-за сохранения совместимости для
старых драйверов.</P>

<br clear=all style='page-break-before:always'>
<H2>Оглавление</H2>
<BR>

</BODY>
</HTML>
